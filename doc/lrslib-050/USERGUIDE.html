<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;
      charset=ISO-8859-1">
    <meta name="GENERATOR" content="Mozilla/4.77 [en] (X11; U; Linux
      2.4.17-686 i686) [Netscape]">
    <title>User's Guide for lrs</title>
  </head>
  <body alink="#ff0000" link="#0000ef" text="#000000" vlink="#55188a">
    <div style="text-align: left;"></div>
    <ul>
      <h3> &nbsp;User's Guide for lrs - Version 4.2b</h3>
      <h3> <font size="-0">June 1, 2012
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Copyright(C)
2012
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
            href="http://cgm.cs.mcgill.ca/%7Eavis/C/lrs.html"> lrs home
            page</a> </font></h3>
    </ul>
    <h3> <font size="-0">&nbsp; David
        Avis&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        avis@cs.mcgill.ca&nbsp;&nbsp;&nbsp;&nbsp; <a
          href="http://cgm.cs.mcgill.ca/%7Eavis">
          http://cgm.cs.mcgill.ca/~avis</a>
      </font></h3>
    <li><a href="#v4.3">What's
        New
        in
        Version 4.3</a></li>
    <li><a
        href="http://cgm.cs.mcgill.ca/%7Eavis/C/lrslib/USERGUIDE.html#v4.2">What's
New
in
Version
        4.2</a></li>
    <li><a href="USERGUIDE.html#What%27s%20New%20in%20Version%204.1">&nbsp;What's
New
in
Version
        4.1</a> </li>
    <li> <a href="#What%27s%20New%20in%20Version%204.0">What's New in
        Version 4.0</a> </li>
    <li> <a href="#Introduction">Introduction&nbsp; (revised)</a> </li>
    <li> <a href="#Installation%20Section">Installation&nbsp;&nbsp;&nbsp;
        (revised)</a> </li>
    <li> <a href="#File%20Formats">File Formats</a> </li>
    <li> <a href="#Options">Basic Options&nbsp; (revised)</a> </li>
    <li> <a href="#Arithmetic%20Packages">Arithmetic Packages&nbsp;</a>
    </li>
    <li> <a href="#Estimation">Estimation</a></li>
    <li><a href="#fourier">&nbsp;Fourier Elimination (new in V4.2)</a><br>
    </li>
    <li> <a href="#Linear%20Programming">Linear Programming(revised)</a></li>
    <li>&nbsp;<a href="#nash">Nash Equilibria (new in V4.2)</a><br>
    </li>
    <li> <a href="#Volume%20Computation">Volume and Triangulation</a> </li>
    <li> <a href="#Voronoi%20Diagrams">Voronoi Diagrams</a> </li>
    <li> <a
        href="#Extreme%20Point%20Enumeration%20and%20Redundant%20Inequalities">Extreme
Point
Enumeration
        and Redundant Inequalities</a> </li>
    <li> <a href="#Linearities">Linearities</a> </li>
    <li> <a href="#Timing%20and%20Interrupts">Timing and Interrupts</a>
    </li>
    <li> <a href="#Timing%20and%20Interrupts">Error Messages and
        Troubleshooting</a> </li>
    <li> <a href="#Hints%20and%20Comments">Hints and Comments</a> </li>
    <li> <a href="#Acknowledgements">Acknowledgements and References<br>
      </a>
      <hr style="width: 100%; height: 2px;">
      <h3><a name="v4.3"></a>What's New in Version 4.3</h3>
    </li>
    <li>Some corrections to the truncate option, which will produce all
      lex-positive bases representing a given vertex. See <a
        href="lexpos.html">here</a> for a description.</li>
    <br>
    <h3><a name="v4.2"></a>What's New in Version 4.2c</h3>
    <br>
    <li>2nash is a 2-processor parallel version of
nash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      (added
      2009.2.18)<br>
    </li>
    <li>Bug fix for fourier: linearities
disabled&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      (added
      2009.2.18)<br>
    </li>
    <li>Triangulation of V-representation output via "volume" and
      "verbose"
      options</li>
    <li>Estimator provides running time estimate</li>
    <li>Bug fix related to memory allocation of linearity option.</li>
    <li>Bug fix for nash, and inclusion of polytope version via <span
        style="color: rgb(0, 0, 153);">setupnash2</span>.</li>
    <li>incidence option now compatible with printcobasis n.<br>
      <h3>What's New in Version 4.2a</h3>
    </li>
    <li>Bug fixed relating to mis-scaled lp dual variables output when <span
        style="color: rgb(0, 0, 153);">lponly</span> set<br>
      <br>
      maxoutput n&nbsp;&nbsp; Option limits output lines to n: either
      rays+vertices, or facets.<br>
      <br>
      <a href="#Acknowledgements"> </a>
      <h3>What's New in Version 4.2<br>
      </h3>
    </li>
    The main additions in Version 4.2 are two new drivers:<br>
    <br>
    <ul>
      <li><span style="color: rgb(0, 0, 153);"><span style="font-weight:
            bold;"><a href="#nash">nash</a>:</span>&nbsp;</span>
        Computes
        all Nash equlibria of a two person non-cooperative game. Can
        handle
        bounds on payoff functions.<br>
      </li>
      <li><font color="#990000"><a href="#fourier"><span style="color:
              rgb(0, 0, 153); font-weight: bold;">fourier</span><span
              style="font-weight: bold;">:</span></a> </font>Projects a
        polyhedron
        given by an H-representation onto a
        subspace using Fourier elimination (contributed by Tallman
        Nkgau).<br>
      </li>
    </ul>
    <br>
    There is a new <a href="#Options"><span style="color: rgb(0, 0,
        153);">bound</span></a>
    option in lrs that truncates the reverse search
    tree when the objective function is less than the given bound for a
    maximization problem, or greater than the bound for minimization.
    When
    lrs is used to solve <a href="#Linear%20Programming">LPs</a>, the
    dual
    variables will now be printed for
    the optimum solution.<br>
    <br>
    <br>
    <br>
    Other new <a href="#Options">basic options</a>: <span
      style="color: rgb(0, 0, 153);">dualperturb, project, printslack<br>
    </span><font color="#cc0000"></font> The <font color="#000099">nonnegative</font>
    option should now work correctly&nbsp; even if the origin is not a
    vertex of the
    polyhedron.<br>
    <h3>
      <hr width="100%"></h3>
    <h3> <a name="What's New in Version 4.1"></a> What's New in Version
      4.1</h3>
    Version 4.1 of<font color="#3333ff"> lrslib</font> contains no
    substantial revisions to the basic algorithms, but contains complete
    garbage collection and some simple drivers for solving vertex
    enumeration, convex hull and linear programming problems on generate
    polyhedra. The generation of input internally is simplified by the
    inclusion of some lpsolve like procedures to enable easy
    construction
    of the constraint matrix. Documentation for this is contained in <font
      size="-0"><a
        href="http://cgm.cs.mcgill.ca/%7Eavis/C/lrslib/lrslib.html">
        http://cgm.cs.mcgill.ca/~avis/C/lrslib/lrslib.html</a> </font>
    <p>A new feature of the basic package is the <font color="#000099">nonnegative</font>
      option that speeds up the solution of problems with
      H-representation:
    </p>
    <blockquote>b+Ax &gt;= 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      x&gt;=0<br>
      <br>
    </blockquote>
    <span style="color: rgb(153, 0, 0);">Note:</span> The origin must be
    a
    vertex of the feasible region for Version 4.1.<br>
    <hr width="100%">
    <h3> <a name="What's New in Version 4.0"></a> What's New in Version
      4.0 (included in Version 4.1)</h3>
    <font size="-0">Version 4.0 of <font color="#3333ff">lrs</font> is
      distributed as the callable library <font color="#3333ff">lrslib</font>.
      Two
      drivers are supplied, <font color="#3333ff">lrs.c</font> and <font
        color="#3333ff">redund.c</font> , that replace the corresponding
      programs in previous distributions. The new programs should be
      compatible with earlier ones, and correctly process existing input
      files. New in this version is that input files need not be of full
      dimension, and input equations or <a href="#Linearities">linearities</a>
      may be specified. In addition, input files may contain redundant
      columns, which are closely connected to linearities. See also the
      section <a href="#File%20Formats"> File Formats</a> for more
      information.</font>
    <p>This distribution also comes with three&nbsp; <a
        href="#Arithmetic%20Packages"> arithmetic</a> lpackages:<font
        color="#3333ff"> lrsmp,</font> <font color="#3333ff">lrslong </font><font
        color="#000000">and </font><font color="#3333ff">lrsgmp</font>
      . The
      library lrsmp is essentially the same extended precision package
      included in earlier distributions. lrslong is an implementation
      using
      long integer arithmetic, which is considerably faster, but does no
      overflow checking. lrsgmp is an interface to<a
        href="http://www.swox.com/gmp"> GNU MP</a> which must be
      installed
      first. Binaries are produced for all arithmetic packages using the
      distributed make file. </p>
    <p>Most of the functions required for <font color="#3333ff">lrs</font>
      and <font color="#3333ff">redund</font> are included in the
      library<font color="#3333ff"> lrslib</font>. This is compiled with
      either of the
      arithmetic packages. One of the purposes of supplying a library is
      to
      allow simple customization of the reverse search procedure. The
      program
      <font color="#3333ff">lrs.c</font> is the reverse search driver,
      and
      supplies each output vector to the user. It can be customized to
      prune
      the search according to various criteria,
      eg., if the value of some objective function falls below some
      value, or
      if
      an integer vector is produced etc. </p>
    <p>The <a href="#Installation%20Section">installation</a> procedure
      has been
      simplified, and the package is distributed as a compressed tar
      file.
      Included
      is a makefile for various configurations and some typical input
      files.
      Binaries
      are also included for some platforms. </p>
    <p>There are new options:&nbsp; <a href="#Options">incidence</a> ,
      which lists
      all inequalities (resp. vertices/rays) which are incident with the
      current
      output vertex/ray (resp. facet). and <a href="#Options">truncate</a>
      which
      prunes the search tree everytime a vertex different from the
      starting
      vertex
      is reached. <br>
    </p>
    <hr width="100%">
    <h3> <a name="Introduction"></a> Introduction</h3>
    A polyhedron can be described by a list of inequalities (<i>H-representation)</i>
    or as by a list of its vertices and extreme rays (<i>V-representation).lrs
    </i>is a C program that converts a H-representation of a polyhedron
    to
    its V-representation, and vice versa.&nbsp; These problems are known
    respectively at the <i>vertex enumeration</i> and <i>convex hull
      problems</i>. <br>
    Fukuda's <a
      href="http://www.ifor.math.ethz.ch/staff/fukuda/polyfaq/polyfaq.html">
      FAQ
      page</a> &nbsp; contains a more detailed introduction to the
    problem,
    along
    with many useful tips for the new user.
    <p><i>lrs</i> is based on the <i>reverse search</i> algorithm of <a
        href="http://cgm.cs.mcgill.ca/%7Eavis/doc/avis/AF92b.ps"> Avis
        and
        Fukuda(1992)</a> , modified to use lexicographic pivoting&nbsp;
      and
      implemented in rational arithmetic. See <a
        href="http://cgm.cs.mcgill.ca/%7Eavis/doc/avis/Av98a.ps">
        Avis(1998a) </a>
      for a technical description, and <a
        href="http://cgm.cs.mcgill.ca/%7Eavis/doc/avis/Av98b.ps">
        Avis(1998b)</a>
      for some computational experience. The input files are in <i>Polyhedra
        format</i> , developed by Fukuda and the author. The format is
      essentially
      self-dual, and the output file produced can be read in as an input
      file,
      with very minor modifications, to perform the reverse
      transformation.
      This
      format is compatible with that&nbsp; used in Fukuda's <i><a
          href="http://www.cs.mcgill.ca/%7Efukuda/soft/cdd_home/cdd.html">
          cdd </a>
      </i>package, which performs the same transformations using a
      version of
      the <i>double description method</i>.&nbsp; <i>cdd</i> can also
      be
      used&nbsp; in conjunction with <i>lrs </i>as a pre-processor for
      projections to subspaces, or as a post processor for computing the
      entire face lattice. Another program using the same file format is
      the
      primal-dual method <i><a
          href="http://www.cs.unb.ca/profs/bremner/pd/">pd</a>,</i>
      developed by
      Bremner, Fukuda and Marzetta .&nbsp; It is essentially dual to <i>lrs,</i>
      and is very efficient for computing H-representations of simple
      polyhedra,
      and V-representations of simplicial polyhedra. It will compute the
      volume
      of a polytope given by an H-representation. </p>
    <p>Another program&nbsp; based on the double description method is
      Christof and Loebel's <i><a
          href="http://www.iwr.uni-heidelberg.de/iwr/comopt/software/PORTA/">
          porta</a> , </i>and a versatile tool for the algorithmic
      treatment of
      polytopes is Gawrilow and Joswig's&nbsp; <i><a
          href="http://www.math.tu-berlin.de/diskregeom/polymake/doc">
          polymake</a>
      </i> package. Barber et al.'s <i><a href="http://www.qhull.org/">
          qhull.</a></i>&nbsp;
      A package for volume computation called <a
        href="http://www.lix.polytechnique.fr/Labo/Andreas.Enge/Vinci.html">Vinci</a>
      has been developped by Enge. A comprehensive general source of
      related
      infomation are Erickson's <a
        href="http://compgeom.cs.uiuc.edu/%7Ejeffe/compgeom/">
        Computational Geometry Pages.</a> </p>
    <p>In version 4.0, polyhedra handled by <i>lrs&nbsp;</i> need not
      be
      full dimensional&nbsp; and may contain input linearities and
      redundant
      columns .&nbsp; <i>lrs</i> accepts either integer or rational
      input,
      and produces integer or rational output. All computations are done
      exactly using either extended precision arithmetic or fixed long
      integer arithmetic. In the latter case no overflow checking is
      performed, and the user is advised to check
      results using the extended precision version. Since it is a pivot
      based
      method, <i>lrs</i> can be very slow for degenerate inputs: i.e..
      H-representations of non-simple polyhedra, and V-representations
      of
      non-simplicial polyhedra. On the other hand, it does not store the
      vertices/ rays or facets produced, so for very large problems it
      may be
      the only method that can solve the
      problem.&nbsp; A discussion of various vertex enumeration/convex
      hull
      methods
      and the types of polyhedra that cause them to behave badly is
      contained
      in <a href="http://cgm.cs.mcgill.ca/%7Eavis/doc/avis/ABS96a.ps">
        Avis,
        Bremner and Seidel( 1997).</a> </p>
    <p>Additional functions of <i>lrs</i> include: </p>
    <ul>
      <li> Estimating the number of vertices/rays or facets of a
        polytope,
        and estimating the total running time</li>
      <li> Computing the volume of a polytope given by a
        V-representation</li>
      <li> Solving LP problems for a polyhedron given by a
        H-representation</li>
      <li> Computing the Voronoi vertices and rays for an input set of
        data
        points</li>
      <li> The ability to suspend and restart execution at any time</li>
    </ul>
    A second program, <i>redund</i>, is supplied for removing
    redundancy
    from and H or V-representation. In the former case, this involves
    the
    removal of any inequalities that are not required to represent the
    polyhedron. In the latter case, this is&nbsp; the problem of
    evaluating
    the extreme points and rays of a V-representation. These problems
    are
    normally&nbsp; considerably easier than the transforamtions
    performed by<i>
      lrs</i>. In some cases,
    redundancy can greatly slow the processing time taken by <i>lrs,</i>
    and
    it is advisble to remove any redundancy from the input file using
    redund
    before applying <i>lrs.</i>
    <p>These programs can be distributed freely under the GNU GENERAL
      PUBLIC LICENSE. Please read the file COPYING carefully before
      using.&nbsp; Please inform the author of any interesting
      applications
      for which <i>lrs/redund</i> were helpful. </p>
    <h3>
      <hr width="100%"><a name="Installation Section"></a> Installation</h3>
    <ul>
      <li> Some binaries are available. From lrs home page,&nbsp; click
        on&nbsp; "Download" and change directory to "binaries" and check
        for
        available platforms. These should be usable directly, however to
        get
        source, full documentation and a set of test files, you will
        need to
        retrieve lrslib-042 as described below.</li>
      <br>
      &nbsp;
      <li> From lrs home page, click on "Download" and retrieve the
        file lrslib-042.tar.gz</li>
      <br>
      &nbsp;
      <li> Unpack with:</li>
      <br>
      &nbsp;&nbsp; % gunzip lrslib-042.tar.gz <br>
      &nbsp;&nbsp; % tar xvf lrslib-042.tar
      <ul>
        &nbsp;
      </ul>
      <li> Go to the new directory</li>
      <br>
      % cd lrslib-042 <br>
      &nbsp;
      <li> &nbsp;make all binaries (delete those not needed
        afterwards)<br>
      </li>
      <br>
      &nbsp;&nbsp; % make
      all&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(most
32
      bit unix machines) <br>
      or <br>
      &nbsp; % make
      all64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(64
bit
      integer machines such as DEC Alpha) <br>
      or <br>
      &nbsp; % make nosigs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (
      ansi
      standard version for 32 bit machines without signals/timing
      routines) <br>
      &nbsp;
      <li> If you have GNU MP installed you can obtain binaries <font
          style="color: rgb(0, 0, 153);" color="#3333ff"> glrs</font>, <span
          style="color: rgb(0, 0, 153);">gnash</span>, <span
          style="color: rgb(0, 0, 153);">2gnash</span> and <font
          style="color: rgb(0, 0, 153);" color="#3333ff">gredund</font>
        using this library by typing</li>
      <br>
      &nbsp; % make gmp <br>
      It may be necessary to edit makefile to set the paths to the gmp
      library <br>
      &nbsp; <br>
      &nbsp;
      <li> Test the program <span style="color: rgb(0, 0, 153);">lrs</span>
        by typing:</li>
      <ul>
        <b><font color="#000066">lrs&nbsp; cube.ine</font></b>
      </ul>
      This will convert the H-representation of a cube given cube by 6
      the
      six inequalities -1 &lt;= x<sub>i </sub>&lt;= 1 , i=1,2,3 given
      by the
      input: <br>
      <b><font color="#000099">cube</font></b> <br>
      <b><font color="#000099">*cube of side 2 centred at the origin</font></b>
      <br>
      <b><font color="#000099">H-representation</font></b> <br>
      <b><font color="#000099">begin</font></b> <br>
      <b><font color="#000099">6 4 rational</font></b> <br>
      <b><font color="#000099">1 1 0 0</font></b> <br>
      <b><font color="#000099">1 0 1 0</font></b> <br>
      <b><font color="#000099">1 0 0 1</font></b> <br>
      <b><font color="#000099">1 -1 0 0</font></b> <br>
      <b><font color="#000099">1 0 -1 0</font></b> <br>
      <b><font color="#000099">1 0 0 -1</font></b> <br>
      <b><font color="#000099">end</font></b>
      <p>The output should contain (along with other comment lines
        beginning with a "*")</p>
    </ul>
    <ul>
      <b><font color="#ff0000">cube</font></b> <br>
      <b><font color="#ff0000">V-representation</font></b> <br>
      <b><font color="#ff0000">begin</font></b> <br>
      <b><font color="#ff0000">***** 4 rational</font></b> <br>
      <b><font color="#ff0000">&nbsp;1&nbsp; 1&nbsp; 1&nbsp; 1</font></b>
      <br>
      <b><font color="#ff0000">&nbsp;1 -1&nbsp; 1&nbsp; 1</font></b> <br>
      <b><font color="#ff0000">&nbsp;1&nbsp; 1 -1&nbsp; 1</font></b> <br>
      <b><font color="#ff0000">&nbsp;1 -1 -1&nbsp; 1</font></b> <br>
      <b><font color="#ff0000">&nbsp;1&nbsp; 1&nbsp; 1 -1</font></b> <br>
      <b><font color="#ff0000">&nbsp;1 -1&nbsp; 1 -1</font></b> <br>
      <b><font color="#ff0000">&nbsp;1&nbsp; 1 -1 -1</font></b> <br>
      <b><font color="#ff0000">&nbsp;1 -1 -1 -1</font></b> <br>
      <b><font color="#ff0000">end</font></b>
      <p>This is a list of the 8 vertices with each co-ordinate +/-
        1.&nbsp; The ***** should be replaced by the actual number, 8,
        of
        vertices. Since <i> lrs</i> does not save the output produced,
        it does
        not know this value until the execution terminates. This output
        is now
        essentially the same as file cube.ext. To complete the test
        type: <br>
        &nbsp; </p>
      <ul>
        <b><font color="#000066">lrs&nbsp; cube.ext</font></b>
      </ul>
      <font color="#000000">Now the output produced is essentially the
        file
        cube.ine, with the inequalities appearing in a different order.</font>
      <p>The program buffer is a small utility that can be used to
        remove
        duplicate line in the output that may occur if the input is not
        a
        polytope or a pointed cone. For such unbounded polyhedra,&nbsp;
        rays
        may appear in the output more than once. The program takes two
        optional
        integer parameters: </p>
      <ul>
        <b><font color="#000099">buffer&nbsp; maxline maxbuffer</font></b>
      </ul>
      It builds a circular buffer of maxbuffer (default 50) lines of
      maxline
      (default 5000)characters each. If an output line is already in the
      buffer, it is not output.&nbsp; To use buffer, pipe the output
      from <i>lrs</i>:
      <ul>
        <b><font color="#000099">lrs&nbsp; filename | buffer</font></b>
      </ul>
    </ul>
    <h3>
      <hr width="100%"><a name="File Formats"></a> File Formats</h3>
    <ul>
      Example files can be found in the directories ine and ext which
      come
      in the standard distribution. File formats were developed jointly
      with
      Komei Fukuda and are compatible with <a
        href="http://www.cs.mcgill.ca/%7Efukuda/soft/cdd_home/cdd.html">
        cdd</a>
      . The cdd manual contains additional information and examples.
    </ul>
    <ul>
      The input for<i> lrs</i> is a H- or V- representation of a
      polytope.
      These files have the following formats:
      <h4> H-representation</h4>
      <hr width="100%"> <br>
      <i>name</i> <br>
      <font color="#3333ff">H-representation</font> <br>
      {options} <br>
      {<a href="#Linearities">linearities</a>
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font
        color="#cc0000"> /* new in version 4.0 */</font> <br>
      <font color="#3333ff">begin</font> <br>
      <font color="#3333ff">m n rational</font>
      <p>{list of inequalities } </p>
      <p><font color="#3333ff">end</font> <br>
        {options} </p>
      <hr width="100%"> <br>
      &nbsp;
      <p><i>name<u> </u></i>is a user supplied name for the
        polytope.&nbsp; If the line H-representation is omitted,
        H-representation is assumed.&nbsp; The input coefficients are
        read in
        free format, and are not checked for type.
        Coefficients are separated by white space. Normally this file
        would be
        saved
        with filename suffix .<i>ine </i>but this not required.&nbsp;
        Comments
        may
        appear before the begin or after the end, and to avoid
        interpretation
        as
        an option, should begin with a special character such as "*" or
        "#". <br>
        The integer&nbsp; m is the number of inequalities,&nbsp; and the
        integer n is the dimension of the input +1. <br>
        A list of inequalities contains the coefficients of inequalities
        of the
        form </p>
      <p>a<sub>0</sub> + a<sub>1 </sub>x<sub>1 </sub>+ ... + a<sub>n-1</sub>
        x<sub>n-1</sub> &gt;=&nbsp; 0. </p>
      <p>This inequality is input as the line </p>
      <p>a<sub>0 </sub>a<sub>1 </sub>... a<sub>n-1</sub> <br>
        &nbsp; </p>
      <p>The coefficients can be entered as integers or rationals in the
        format x/y. <br>
        For example, the square centred at the origin with side length
        two has
        inequalities </p>
      <p>1 + x<sub>1</sub> &gt;= 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1+ x<sub>2
        </sub>&gt;=0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1-x<sub>
          1 </sub>&gt;=
        0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        1-x<sub>2 </sub>&gt;=0 </p>
      <p>and would be represented by the input file </p>
      <p><b><font color="#000099">square</font></b> <br>
        <b><font color="#000099">*centred square of side 2</font></b> <br>
        <b><font color="#000099">H-representation</font></b> <br>
        <b><font color="#000099">begin</font></b> <br>
        <b><font color="#000099">4 3 rational</font></b> <br>
        <b><font color="#000099">1 1 0</font></b> <br>
        <b><font color="#000099">1 0 1</font></b> <br>
        <b><font color="#000099">1 -1 0</font></b> <br>
        <b><font color="#000099">1 0 -1</font></b> <br>
        <b><font color="#000099">end</font></b> <br>
        &nbsp; </p>
      <h4> V-representation</h4>
      <hr width="100%"> <br>
      <i>name</i> <br>
      <font color="#3333ff">V-representation</font> <br>
      {options} <br>
      {<a href="#Linearities">linearities</a>
      }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;


      <font color="#cc0000">/* new in version 4.0 */</font> <br>
      <font color="#3333ff">begin</font> <br>
      <font color="#3333ff">m n rational</font>
      <p>{list of vertices and extreme rays} <br>
        <font color="#3333ff">end</font> <br>
        {options) <br>
      </p>
      <hr width="100%"> <br>
      <i>name<u> </u></i>is a user supplied name for the
      polytope.&nbsp;
      The line V-representation is required.&nbsp; The input
      coefficients are
      read in free format, and are not checked for type. Coefficients
      are
      separated
      by white space. Comments may appear before the begin or after the
      end,
      and
      to avoid interpretation as an option, should begin with a special
      character
      such as "*" or "#".Normally this file would be stored with
      filename
      suffix
      .<i> ext</i>, but this is not required.
      <p>The integer&nbsp; m is the number of vertices and rays,&nbsp;
        and
        the integer n is the dimension of the input +1. <br>
        Each vertex is given in the form </p>
      <p>1&nbsp;&nbsp; v<sub>0&nbsp;&nbsp;</sub> v <sub>1 </sub>...&nbsp;&nbsp;
        v<sub>n-1</sub> <br>
        &nbsp; </p>
      <p>Each ray is given in the form </p>
      <p>0&nbsp;&nbsp; r<sub>0&nbsp;&nbsp;</sub> r <sub>1 </sub>...&nbsp;&nbsp;
        r<sub>n-1</sub> </p>
      <p>where r<sub>0&nbsp;&nbsp;</sub> r <sub>1 </sub>...&nbsp;&nbsp;
        r<sub>
          n-1</sub>is a point on the ray. </p>
      <p>There must be at least one vertex in each file. For bounded
        polyhedra there will be no rays entered. <br>
        The coefficients can be entered as integers or rationals in the
        format
        x/y. <br>
        For example, the unit square centred at the origin has vertices
        <br>
        (1,1) ,(1,-1),(-1,1),(-1,-1) <br>
        and would be represented by the input file </p>
      <p><b><font color="#000066">square</font></b> <br>
        <b><font color="#000099">*centred square of side 2</font></b> <br>
        <b><font color="#000066">V-representation</font></b> <br>
        <b><font color="#000066">begin</font></b> <br>
        <b><font color="#000066">4 3 rational</font></b> <br>
        <b><font color="#000066">1 1 1</font></b> <br>
        <b><font color="#000066">1 1 -1</font></b> <br>
        <b><font color="#000066">1 -1 1</font></b> <br>
        <b><font color="#000066">1 -1 -1</font></b> <br>
        <b><font color="#000066">end</font></b> </p>
      <p>The positive quadrant has vertex (0,0) and rays (1,0) (0,1) and
        is
        represented </p>
      <p><b><font color="#000066">quadrant</font></b> <br>
        <b><font color="#000099">*positive quadrant</font></b> <br>
        <b><font color="#000066">V-representation</font></b> <br>
        <b><font color="#000066">begin</font></b> <br>
        <b><font color="#000066">3 3 rational</font></b> <br>
        <b><font color="#000066">1 0 0</font></b> <br>
        <b><font color="#000066">0 1 0</font></b> <br>
        <b><font color="#000066">0 0 1</font></b> <br>
        <b><font color="#000066">end</font></b> </p>
      <p>Its H-representation contains the inequalities x<sub>1 </sub>&gt;=
0
and
        x<sub>2</sub> &gt;= 0 : </p>
      <p><b><font color="#000099">quadrant</font></b> <br>
        <b><font color="#000099">*positive quadrant</font></b> <br>
        <b><font color="#000099">H-representation</font></b> <br>
        <b><font color="#000099">begin</font></b> <br>
        <b><font color="#000099">2 3 rational</font></b> <br>
        <b><font color="#000099">0 1 0</font></b> <br>
        <b><font color="#000099">0 0 1</font></b> <br>
        <b><font color="#000099">end</font></b> <br>
        &nbsp; <br>
        &nbsp;</p>
    </ul>
    <a name="Note for cdd users"></a> <b>Note for cdd users</b>: <i>lrs</i>
    uses essentially the same file format as <i>cdd</i>. Files prepared
    for <i>cdd</i> should work with little or no modification. Note
    that&nbsp; the V-representation corresponds to the "hull" option in
    <i>cdd</i>.
    Options
    specific to <i>cdd</i> can be left in the input files and will
    be ignored by <i>lrs</i>.&nbsp;
    Note the input files for <i> lrs</i> are read in free format, after
    the
    line <b><font color="#000099"> m n rational </font></b><font
      color="#000000"><i><span style="font-weight: bold;">l</span>rs</i>
      will look for exactly m*n rationals or
      integers separated by white space (blank,&nbsp; carriage return,
      tab
      etc.). <i>lrs</i> will not "drop" extra columns of input if n is
      less
      than the number of columns supplied.</font> <br>
    <hr width="100%">
    <h3> <a name="Options"></a> Basic Options</h3>
    <div style="margin-left: 40px;"><span style="color: rgb(153, 0, 0);">New
for
Version
        4.2: bound, dualperturb, printslack, project</span><br>
    </div>
    <ul>
      <i>lrs</i> has many options to allow various functions to be
      performed, and to modify the output produced. Almost all options
      are
      placed <b>after</b> the end statement, maintaining compatibility
      with <i>cdd</i>.
      Where
      this is not the case, it will be mentioned explicitly. All
      options are optional.
    </ul>
    <b><font color="#000099">allbases</font></b>
    <ul>
      This option instructs <i>lrs</i> to list each vertex (or facet)
      for
      each of its bases. Normally a vertex (or facet) is only output
      when its
      lex-min basis is found, to avoid duplications - see section <a
        href="#Output%20Duplication"> Output Duplication </a> <a
        href="#Hints%20and%20Comments">.</a> This option is often
      combined
      with <font color="#000066">printcobasis</font> .
    </ul>
    <b><font color="#000066">bound&nbsp; x
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      </font></b><font color="#cc0000">New in Ver
      4.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
      Use
      with H-representation&nbsp; - for lrs or nash //<br>
    </font>
    <div style="margin-left: 40px;">Either the maximize or minimize
      option
      should be selected. x is an integer or rational.<br>
      For maximization (resp. minimization) the reverse search tree is
      truncated&nbsp; whenever the current objective value is less
      (resp.
      more) than x .<br>
    </div>
    <font color="#cc0000"><br>
    </font><b><font color="#000099">cache n</font></b>
    <ul>
      <i>lrs</i> stores the latest&nbsp; n dictionaries in the reverse
      search tree. This speeds up the backtracking step, but requires
      more
      memory.&nbsp; If n is set to one, there is no caching and "pure"
      reverse search is performed.&nbsp; The default is n=10. At the end
      of a
      run a message gives cache information. The output <br>
      <b><font color="#ff0000">*Dictionary Cache: max size= 4 misses=
          10/1340&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tree Depth=5</font></b>
      <br>
      indicates that with cache size set to 4, only 10&nbsp; of the 1340
      dictionaries computed were not in the cache&nbsp; during
      backtracking
      and had to be
      recomputed. The maximum tree depth was 5, so there would be no
      misses
      with
      a cache size of 6. Full caching reduces processing time by about
      40%.
    </ul>
    <b><font color="#000066">debug&nbsp; startingbasis endingbasis</font></b>
    <blockquote>Print out cryptic but detailed trace, dictionaries etc.
      starting at #B=startingbasis and ending at #B=endingbasis. <b><font
          color="#000066"> debug 0 0 </font></b><font color="#000000">gives
        a
        complete trace.</font></blockquote>
    <b><font color="#000066">digits n&nbsp;</font>&nbsp;&nbsp;&nbsp;</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
placed
    before the begin statement//
    <ul>
      n is the maximum number of decimal digits to be used. If this is
      exceeded the program terminates with a message (it can&nbsp;
      usually be
      restarted).&nbsp;&nbsp; The default is set to about 100 digits. At
      the
      end of a run a message is given informing the user of the maximum
      integer size encountered. This may be used to optimize memory
      usage and
      speed on subsequent runs (if doing estimation for example). The
      output: <br>
      <b><font color="#ff0000">*Max digits= 45/100</font></b> <br>
      indicates that the maximum integer encountered had 45 decimal
      digits,
      and the program allowed up to 100 digit integers.<br>
    </ul>
    <b><font color="#000099">dualperturb<br>
      </font></b>
    <div style="margin-left: 40px;">If<span style="font-style: italic;">
        lrs</span>
      is executed with the <span style="color: rgb(0, 0, 153);">maximize</span>
      or <span style="color: rgb(0, 0, 153);">minimize</span> option,
      the
      reverse search tree is rooted at an optimum vertex for this
      function.<br>
      If there are mulitiple optimum vertices, the output will often not
      be
      complete. This option gives a small perturbation to the objective
      to
      avoid this.<br>
      A warning message is given if the starting dictionary is dual
      degenerate .<br>
    </div>
    <b><font color="#000099"><br>
      </font></b><b><font color="#000099">estimates k</font></b>
    <ul>
      Estimate the output size. Used in conjunction with maxdepth - see
      <a href="#Estimation"> Estimation.</a>
    </ul>
    <ul>
      &nbsp;
    </ul>
    <b><font color="#000066">geometric</font>&nbsp;&nbsp;</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
H-representation&nbsp;
    or voronoi option only //
    <ul>
      With this option, each ray is printed together with the vertex
      with
      which it is incident. They output has the form:
    </ul>
    <ul>
      &nbsp;&nbsp; 0&nbsp;&nbsp; r<sub>0&nbsp;&nbsp;</sub> r <sub>1 </sub>...&nbsp;&nbsp;
      r<sub>n-1</sub>* 1&nbsp;&nbsp; v<sub>0&nbsp;&nbsp;</sub> v <sub>1
      </sub>...&nbsp;&nbsp;
      v<sub>n-1</sub>
    </ul>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
This
indicates
    ray&nbsp; 0&nbsp;&nbsp; r<sub>0&nbsp;&nbsp;</sub> r <sub>1
    </sub>...&nbsp;&nbsp; r<sub>n-1</sub>is incident with vertex&nbsp;
    1&nbsp;&nbsp; v<sub>0&nbsp;&nbsp;</sub> v <sub>1 </sub>...&nbsp;&nbsp;
    v<sub>n-1</sub>.&nbsp; For the quadrant, the output is:
    <ul>
      <b><font color="#ff0000">1 0 0</font></b> <br>
      <b><font color="#ff0000">0 0 1 * 1 0 0</font></b> <br>
      <b><font color="#ff0000">0 1 0 * 1 0 0</font></b> <br>
      This indicates the origin is a vertex, and there are two geometric
      rays: (0,t) and (t,0) both adjacent to the origin. For more
      information
      see Geometric Rays in <a href="#Hints%20and%20Comments">Hints and
        Comments</a> .
    </ul>
    <b><font color="#000066">incidence&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font
        color="#cc0000"> &nbsp; // New in version 4.0 //</font></b>
    <blockquote><font color="#000000">This option automatically switches
        on </font><b style="color: rgb(153, 0, 0);">printcobasis</b><font
        color="#000000"> , so see below for a description of this option
        first. <br>
        Can be used with <span style="color: rgb(153, 0, 0);">printcobasis
          n</span>.
        (Ver
        4.2b)</font>
      <p><font color="#000000">For input H-representation, indices of
          all
          input inequalities that contain the vertex/ray that is about
          to be
          output. For a simplicial face, there is no new output, since
          these
          indices are already listed. Otherwise, the additional tight
          inequalities are listed after a colon.
          Eg:</font> <br>
        <b><font color="#ff0000">V#1 R#0 B#1 h=0 facets&nbsp; 12 14 15
            16 : 9 10 11 13 I#8 det= 8</font></b> <br>
        <b><font color="#ff0000">&nbsp;1&nbsp; 0&nbsp; 0&nbsp; 0&nbsp;
            1</font></b> <br>
        <font color="#000000">The vertex </font><b><font
            color="#ff0000">0 0
            0 1</font></b><font color="#000000"> satisfies 8 input
          inequalities as
          equations, as indicated by </font><b><font color="#ff0000">I#8</font></b><font
          color="#000000"> : those with indices </font><b><font
            color="#ff0000">12,14,15,16</font></b><font color="#000000">
          are in the cobasis, and those with indices </font><b><font
            color="#ff0000"> 9, 10, 11, 13 </font></b><font
          color="#000000">are
          in the basis. For a ray:</font> <br>
        <b><font color="#ff0000">V#1 R#5 B#1 h=0 facets&nbsp; 5 9* 10 11
            12
            13 : 2 3 4 I#8 det= 8</font></b> <br>
        <b><font color="#ff0000">&nbsp;0&nbsp; 1&nbsp; 1&nbsp; 0&nbsp;
            0&nbsp; 1&nbsp; 1</font></b> <br>
        <font color="#000000">Here the ray </font><b><font
            color="#ff0000">
            1&nbsp; 1&nbsp; 0&nbsp; 0&nbsp; 1&nbsp; 1 </font></b><font
          color="#000000"> lies on 8 inequalities, with indices </font><b><font
            color="#ff0000">5 10 11 12 13</font></b><font
          color="#000000"> in
          basis and </font><b><font color="#ff0000"> 2 3 4</font><font
            color="#000000"> i</font></b><font color="#000000">n
          cobasis. The
          starred index</font><b><font color="#ff0000"> 9*</font></b><font
          color="#000000"> indicates that the ray is terminated by the
          input
          inequality 9. This inequality is in the cobasis and defines
          the vertex
          from which the ray starts.</font> </p>
      <p><font color="#000000">For input V-representation, indices of
          all
          input vertices/rays that lie on the facet that is about to be
          output:</font> <br>
        <b><font color="#ff0000">F#5 B#3 h=2 vertices/rays&nbsp; 7 8* 11
            13
            15 : 1 3 5 9 I#8 det= 16</font></b> <br>
        <b><font color="#ff0000">1 -1&nbsp; 0&nbsp; 0&nbsp; 0</font></b>
        <br>
        <font color="#000000">The facet generated by inequality x<sub>1</sub>
          &lt;= 1 contains 8 input vertices, as indicated by I#8: those
          with
          indices </font><b><font color="#ff0000">7,11,13,15</font></b><font
          color="#000000"> are in the cobasis, and those with indices</font><b><font
            color="#ff0000"> 1 3 5 9 </font></b><font color="#000000">are
          in the
          basis.The starred index</font><b><font color="#ff0000"> 8*</font></b><font
          color="#000000"> indicates that this vertex&nbsp; is also in
          the
          cobasis, but is not contained in the facet. It arises due to
          the
          lifting operation used with input V-representations.</font></p>
    </blockquote>
    <b><font color="#000099">#incidence</font></b>
    <blockquote><font color="#000000">The same as printcobasis. Included
        for compatability
        with <i>cdd.</i></font></blockquote>
    <b><font color="#000066">linearity&nbsp; k&nbsp; i<sub>1 </sub>i<sub>2
        </sub> i ... i<sub>k</sub></font></b>
    <blockquote>The input contains k linearities in rows <b><font
          color="#000066"> i<sub>1 </sub>i<sub>2 </sub>i ... i<sub>k </sub></font></b>of
the
input
      file are equations. See <a href="#Linearities">Linearities.</a>
    </blockquote>
    <b><font color="#000066">maxdepth k</font></b>
    <ul>
      <font color="#000000">The search will be truncated at depth k. All
        bases with depth less than or equal to k will be computed.&nbsp;
        k
        is&nbsp; a non-negative integer, and this option is used for
        estimates
        - see <a href="#Estimation"> Estimation.</a> </font> <br>
      <font color="#000000"><b>Note</b>: For H-representations, rays at
        depth k will not be reported. For V-representations, facets at
        depth k
        will not be reported.</font>
    </ul>
    <b><font color="#000099">maximize&nbsp; </font></b><b><font
        color="#000099">a<sub>0</sub>
        a<sub>1 </sub>... a<sub>n-1</sub></font></b>&nbsp;<b><font
        color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></b>
    // H-representation&nbsp; only // <br>
    <b><font color="#000099">minimize&nbsp;&nbsp; </font></b><b><font
        color="#000099"> a<sub>0</sub>
        a<sub>1 </sub>... a<sub>n-1</sub></font></b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
H-representation&nbsp;
    only //
    <ul>
      <sub></sub>
    </ul>
    <div style="margin-left: 40px;">If used with <span
        style="font-style: italic;">lrs</span> the starting vertex
      maximizes
      (or minimizes) the function&nbsp; a<sub>0</sub> + a<sub>1 </sub>x<sub>
        1 </sub>+ ... + a<sub>n-1</sub> x<sub>n-1</sub>.<br>
      The dualperturb option may be needed to avoid dual degeneracy.<br>
      See Nash Equilibria and&nbsp; <a href="#Linear%20Programming">Linear
        Programming</a></div>
    <ul>
      <font color="#000000"> </font>
    </ul>
    <font color="#000066">maxoutput n&nbsp;&nbsp;&nbsp; // from Version
      4.2a //<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>Limits number of
    output
    lines produced (either vertices+rays or facets) to n<font
      color="#000066"><br>
      <b><br>
        mindepth k</b></font>
    <ul>
      <font color="#000066">&nbsp;</font><font color="#000000">Backtracking
will
        be terminated at depth k, for k a non-negative integer. This can
        be used for running reverse search on subtrees as separate
        processes,
        e.g. in a distributed computing environment.</font>
    </ul>
    <b><font color="#000066">nonnegative&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      </font><font color="#990000">//modified in lrs 4.2
        //&nbsp;&nbsp;&nbsp;</font><font color="#000066">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></b><font
      color="#cc0000"> // This option must come before the begin
      statement//</font>
    <br>
    <font color="#cc0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//H-representation
only
      //</font> <br>
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<font color="#990000">Bug:</font>
    Can only be used if the origin is a vertex of the polyhedron&nbsp;
    <blockquote><font color="#000000">For problems where the input is an
        H-representation of the form b+Ax&gt;=0, x&gt;=0 (ie. all
        variables
        non-negative, all constraints inequalities) it is not necessary
        to give
        the non-negative constraints explicitly if the </font><font
        color="#000099">nonnegative</font><font color="#000000"> option
        is
        used. This option cannot be used for V-representations, or with
        the </font><font color="#000099">linearit</font><font
        color="#000000">y option (in
        which case the linearities will be treated as
        inequalities). This option may be used with </font><font
        color="#000099">redund</font><font color="#000000"> , but the
        implied
        nonnegativity constraints are not tested
        themselves for redundancy. To test everything it is necessary to
        enter
        the
        nonnegativity constraints explicitly in the input file. (In Ver
        4.1,
        the origin must be a vertex).<br>
      </font></blockquote>
    <p><br>
      <b><font color="#000066">printcobasis&nbsp;
k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        </font></b><font color="#cc0000">Modified in lrs4.0</font> </p>
    <ul>
      Every k'th cobasis is printed. <font color="#990000">If k is
        omitted,
        the cobasis is printed for each vertex/ray/facet that is output</font>.
      For
      a long run it is useful to print the cobasis occasionally so that
      the
      program can be restarted if necessary. <br>
      <b>H-representation:&nbsp; </b><font color="#000000">If</font>
      the
      input is an H-representation the cobasis is a list the indices of
      the inequalities from the input file that define the current
      vertex or
      ray. For example, with input cube.ine a typical output is: <br>
      <b><font color="#ff0000">V#5 R#0 B#5 h=1 facets&nbsp; 3 4 5 I#3
          det=1</font></b> <br>
      <b><font color="#ff0000">1 1 1 -1</font></b> <br>
      <font color="#000000">This indicates that the vertex (1,1,-1) is
        defined by the 3rd, 4th and 5th facet inequalities in the input
        file
        being satisfied as equations. It is the (B#)5th</font> <font
        color="#000000">basis computed, and there have been (V#)5
        vertices and
        (R#)0 rays output up to this point. I#3 means that this vertex
        is
        incident
        with 3 input inequalities, ie. it is non-degenerate. See
        option&nbsp; </font><b><font color="#000099"> incidence</font></b><font
        color="#000000"> above for
        more information.</font> <br>
      <font color="#000000">For rays, a cobasis is also printed. In this
        case the cobasis is the cobasis of the vertex from which the ray
        emanates. One of the indices is starred, this indicates the
        inequality
        to be dropped from the cobasis to define the ray. For example
        the
        output:</font> <br>
      <b><font color="#ff0000">V#1 R#6 B#4 h=1 facets&nbsp; 2 4* 5 7 I#3
          det=1</font></b> <br>
      <b><font color="#ff0000">0 1 1 2 1</font></b> <br>
      <font color="#000000">indicates that the ray (1,1,2,1)
        emanates from a vertex with cobasis defined by input
        inequalities 2 4 5
        7 satisfied as equations. The ray is defined by dropping the
        equation
        with
        index 4. Note that there may not appear any vertex in the output
        with
        cobasis
        2 4 5 7, since the corresponding vertex may be degenerate and
        printed
        with
        another (the lex-min) cobasis. To find out which vertices
        correspond to
        which rays, use also the </font><b><font color="#000099">geometric
        </font></b><font color="#000000"> option.&nbsp; Now the output
        may appear:</font> <br>
      <b><font color="#ff0000">V#1 R#6 B#4 h=1 facets&nbsp; 2 4* 5 7 I#3
          det=1</font></b> <br>
      <b><font color="#ff0000">0 1 1 2 1&nbsp; * 1 0 0 0 0</font></b> <br>
      <font color="#000000">This indicates that the ray is incident to
        the
        origin. Alternatively, if the </font><b><font color="#000099">allbases

        </font></b><font color="#000000">option is used, all cobases
        will be
        printed out.</font> <br>
      <b>V-representation</b>: If the input is a V-representation, the
      cobasis is a list of the input vertices /rays that define the
      current
      facet. For example, with input file cube.ext a typical output is:
      <br>
      <b><font color="#ff0000">F#5 B#4 h=3 vertices/rays&nbsp; 2 3 4 5*
          I#3
          det= 8</font></b> <br>
      <b><font color="#ff0000">&nbsp;1&nbsp; 0&nbsp; 0 -1</font></b> <br>
      <font color="#000000">There have been 5 facets output up to this
        point, and 4 bases have been computed. This facet is defined by
        the vertices in positions 2,3,4 in the input file. The
        additional
        cobasis
        index 5* appears because a V-representation is lifted to one
        higher
        dimension
        before processing, and this index fills out the cobasis. I#3
        means that
        this
        facet is incident with 3 input vertices/rays, ie. it is
        non-degenerate.
        See
        option </font><b><font color="#000099">incidence</font></b><font
        color="#000000"> above for more information.</font> <br>
      <font color="#000000">To initiate <i>lrs</i> from this
        facet all 4 indices must be given in this order (omit the *),
        eg.</font> <br>
      <font color="#000099">startingcobasis 2 3 4 5</font> <br>
      <font color="#000000">Similarly, all 4 indices must be
        given in order to restart from this facet:</font> <br>
      <font color="#000099">restart 5 4 3 2 3 4 5<br>
      </font>
    </ul>
    <b><font color="#000066">printslack
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      </font></b><font color="#cc0000">New in Ver
      4.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
      Use
      with H-representation //<br>
      <br>
    </font>
    <div style="margin-left: 40px;"><span style="font-style: italic;">lrs</span>
      prints a list of the indices of the input inequalities that are
      satisfied strictly for the current vertex, ie. corresponding slack
      variable is positive. <br>
      If <span style="color: rgb(0, 0, 102);">nonnegative</span> is
      set, the
      list will also include indices n+i for each decision variable x<sub>i</sub>
      which is positive.<br>
      <br>
    </div>
    <font color="#cc0000"><br>
    </font><b><font color="#000066">project<br>
      </font></b>
    <div style="margin-left: 40px;">Used by driver <a href="#fourier">fourier</a>
      only.<br>
    </div>
    <b><font color="#000066"><br>
      </font></b><font color="#000066"><b>restart&nbsp; V# R# B# depth
        {facet
        #s
        or
        vertex/ray #s</b>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </font><font color="#990000">Modified in lrs4.0</font>
    <ul>
      <font color="#000000"><i>lrs</i> can be restarted from
        any known cobasis. The calculation will proceed to normal
        termination.
        All of the information is contained in the output from a </font><b><font
          color="#000099"> printcobasis</font></b><font color="#000000">
        option.&nbsp; The <b>order of the indices is very important,</b>
        enter
        them exactly as they appear in the output from the previously
        aborted
        run. To restart from cobasis:</font>
    </ul>
    <ul>
      <b><font color="#ff0000">V#5 R#0 B#5 h=1 facets&nbsp; 3 4 5 det=1</font></b>
      <br>
      <font color="#000000">enter:</font> <br>
      <b><font color="#000066">restart 5 0 5 1 3 4 5</font></b>
      <p><b><font color="#ff0000">F#5 B#4 h=3 vertices/rays&nbsp; 2 3 4
            5*
            det= 8</font></b> <br>
        <b><font color="#ff0000">&nbsp;1&nbsp; 0&nbsp; 0 -1</font></b> <br>
        <font color="#000000">enter</font> <br>
        <b><font color="#000066">restart 5 4 3 2 3 4 5</font></b> </p>
      <p><font color="#000000">Note that if some cobasic index is
          followed
          by a "*",&nbsp; then the index only, without the "*", is
          included in
          the restart line.</font> <br>
        <b><font color="#ff0000">Caution: </font></b><font
          color="#000000">
          When restarting, output from the restart dictionary may be
          duplicated,
          and the final totals of number of vertices/rays/facets may
          reflect this.</font></p>
    </ul>
    <b><font color="#000066">startingcobasis i<sub>1 </sub>i<sub>2 </sub>i
        ...
        i<sub>n-1</sub></font></b>
    <ul>
      <font color="#000000">This allows the user to specify a known
        cobasis
        for beginning the reverse search. </font><b><font
          color="#000066"> i<sub>1 </sub>i<sub>2 </sub>i ... i<sub>n-1</sub></font><sub>
        </sub></b><font color="#000000"> is a list of the inequalities
        (for H-representation)
        or vertices/rays (for V-representation) that define a cobasis.
        If it is
        invalid, or this option is not specified, <i>lrs</i> will find
        its own
        starting cobasis. For example, with cube.ine, the user can start
        at
        vertex (-1,1,-1) by specifying:</font> <br>
      <b><font color="#000099">startingcobasis 1 3 4</font></b>
    </ul>
    <b><font color="#000099"><a name="truncate"></a>truncate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></b><font
      color="#000000"> // H-representation only
      //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(153, 0,
        0);"> </span></font><span style="color: rgb(153, 0, 0);">Some
      corrections made in v4.3</span><font color="#000000"></font>
    <blockquote><font color="#000000">The reverse search tree is
        truncated(pruned)&nbsp; whenever a new vertex is encountered. </font><font
        color="#cc0000"> Note</font><font color="#000000">: This does
        note
        necessarily produce the set of all vertices adjacent to the
        optimum
        vertex in the polyhedron, but just a subset of them.</font> See
      <a href="file:///C:/Users/avis/Desktop/temp/lexpos.html">here</a>
      for a description of how to use this option.</blockquote>
    <b><font color="#000066">verbose</font></b>
    <blockquote><font color="#000000">Print slightly more detailed
        information about the run.</font></blockquote>
    <b><font color="#000099">volume&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></b>
    // V-representation&nbsp; only //
    <ul>
      Compute volume - see section <a href="#Volume%20Computation">Volume
        Computation.</a>
    </ul>
    <b><font color="#000099">voronoi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></b>
    // V-representation&nbsp; only - <font color="#990000">place
      immediately after end statement </font>//
    <ul>
      <font color="#000000">Compute Voronoi diagram - see section <a
          href="#Voronoi%20Diagrams">Voronoi Diagrams.</a> </font>
    </ul>
    <h3>
      <hr width="100%"></h3>
    <h3> <a name="Arithmetic Packages"></a> Arithmetic
      Packages&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(new
in
      Version 4.0)</h3>
    Version 4.0 comes with a choice of arithmetic packages. Currently
    available are:
    <p>&nbsp;&nbsp;<font color="#3333ff"> lrsmp</font>&nbsp;&nbsp;&nbsp;&nbsp;
Extended
precision
      arithmetic used in previous releases </p>
    <p>&nbsp;&nbsp;<font color="#3333ff"> lrslong</font>&nbsp;&nbsp;
      Fixed
      length long integer arithmetic. No overflow checking <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
but
5-10
      times faster than lrsmp. </p>
    <p>&nbsp;&nbsp; <font color="#3333ff">lrsgmp</font>&nbsp;&nbsp; An
      interface to GNU MP&nbsp; which must be installed first. <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Runs
1-6
      times faster than lrsmp on typical problems. </p>
    <p>&nbsp; The standard make gives binaries&nbsp;<i> lrs/redund</i>
      with
      <font color="#3333ff">lrsmp</font>, and<i> lrs1/redund1</i> with <font
        color="#3333ff"> lrslong</font>. The fixed integer package is
      particularly useful with 64 bit machines, and fairly large
      combinatorial problems (15-20 dimensions) have been correctly
      solved.
      It may be useful for doing empirical work, eg. searching for
      polyhedra
      with certain properties. Final results should always be checked
      using<font color="#3333ff"> lrsmp</font>. If you have GNU MP
      installed, "make
      gmp" will produce binaries <i>glrs/gredund </i>using this
      library. It
      may be necessary to edit the makefile to specify the path to gmp.
      <br>
      &nbsp; </p>
    <h3>
      <hr width="100%"><a name="Estimation"></a> Estimation</h3>
    <ul>
      The estimation feature of <i>lrs</i> allows estimates to be made
      of
      the output size and running time. These are based on Knuth's
      technique
      for estimating the size of backtracking trees, and are described
      in <a href="http://cgm.cs.mcgill.ca/%7Eavis/doc/avis/AD94a.ps">
        Avis and
        Devroye(1994).</a> &nbsp; The estimate is unbiased, that is the
      expected value of the estimate is the actual value. To get an
      estimate
      use the <font color="#000099">maxdepth</font> option to limit the
      search depth, and the <b><font color="#000099">estimates</font></b>
      option:
    </ul>
    <b><font color="#000066">maxdepth d</font></b> <br>
    <b><font color="#000066">estimates k</font></b>
    <ul>
      This will cause <i>lrs</i> to perform k random probes from
      each&nbsp;
      node of the tree at depth d. k should be at least 1 and d at least
      zero.
    </ul>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The
    running time of <i>lrs</i> is
    proportional to the number of bases, so an estimate of the number of
    bases gives an easy way to estimate the running time for solving the
    complete problem by <i>lrs:&nbsp; total running time = time for
      estimate * estimated number of bases / tree nodes evaluated.<br>
    </i>
    <ul>
    </ul>
    <ul>
      <p><b>H-representation: </b>If the input is an H-representation,
        the
        program gives an unbiased estimate of the number of vertices
        and&nbsp;
        rays in the V-representation,&nbsp; and the total number of
        bases that
        will be computed by <i>lrs. </i>For the H-representation <i>cube.ine</i>,
        the
        options <b><font color="#000099">maxdepth 1 </font></b>and <b><font
            color="#000099"> estimates 1</font></b> produce the output:
        <br>
      </p>
      <p> <font style="color: rgb(153, 0, 0);" color="#ff0000">*<b>Estimates:
            vertices=9&nbsp;&nbsp;&nbsp;
            rays=0&nbsp;&nbsp;&nbsp;
            bases=9</b></font><span style="color: rgb(153, 0, 0);"> </span><br
          style="color: rgb(153, 0, 0);">
        <b style="color: rgb(153, 0, 0);">*Total number of tree nodes
          evaluated: 6</b><br>
        <span style="color: rgb(153, 0, 0);">*<span style="font-weight:
            bold;">Estimated
            total
            running time=0.0 secs&nbsp; <br>
            <br>
          </span></span>In this case the V-representation of the cube is
        estimated to have 9
        vertices, and it is estimated that <i>lrs</i> will compute a
        total of
        9
        bases. The estimate was based on evaluating 6 tree nodes.&nbsp;
        <b>Note</b>:
        The
        estimate for the number of rays may be an overestimate if the
        polyhedron
        is not a cone, since some rays may be duplicated in the output -
        see
        subsection <a href="#Output%20Duplication"> Output Duplication.</a>
      </p>
      <p><b><font color="#000000">V-representation:</font></b> If the
        input
        is
        a V-representation, the program gives an unbiased estimate of
        the
        number of
        facets in the H-representation, and the total number of bases
        that <i>lrs</i>
        will compute.&nbsp; For V-representation <i>cube.ext,</i> the
        options <b><font color="#000099">maxdepth 0 </font></b>and <b><font
            color="#000099">
            estimates 3 </font></b>produce the output: <br>
      </p>
      <p> <b><font color="#ff0000"><span style="color: rgb(153, 0, 0);">*Estimates:
facets=6
bases=7
              volume=8.88889</span><br style="color: rgb(153, 0, 0);">
            <span style="color: rgb(153, 0, 0);">*Total number of tree
              nodes
              evaluated: 10</span><br style="color: rgb(153, 0, 0);">
            <span style="color: rgb(153, 0, 0);">*Estimated total
              running
              time=0.0 secs </span><br>
          </font></b><span style="color: rgb(153, 0, 0);"></span>&nbsp;<br>
        In this cases it is estimated that the H-representation of the
        cube
        will contain 7 facets, and it is estimated that&nbsp; <i>lrs</i>
        will
        compute a total of 7 bases to find it.<br>
        An unbiased estimate of the volume of the polytope is also
        given. The
        estimate was formed by
        evaluating 7 tree nodes.&nbsp; </p>
      <p><b>Voronoi diagrams: </b>Estimates for the number of Voronoi
        vertices and Voronoi rays for a V-representation of a set of
        data
        points may be obtained by combining the <b><font
            color="#000099">voronoi,
            estimates</font></b> and <b><font color="#000099">maxdepth
          </font></b>options. </p>
      <p><b>Repeated estimates:</b> In order to get estimates with
        different random
        probes, <i>lrs</i> can be given a seed for the random number
        generator. There
        are two ways: an option and a command line argument.</p>
    </ul>
    <b><font color="#000066">seed n</font></b>
    <ul>
      <font color="#000000">The integer n is used as a seed for the
        random
        number generator.</font>
      <p>The command line argument is an integer n which will be the
        seed
        and overrides a seed given as an option.</p>
    </ul>
    <b><font color="#000066">lrs n &lt; filename</font></b> <br>
    &nbsp;
    <ul>
      <b>Using the estimator:&nbsp;</b> For the case of polytopes that
      contain
      the origin, a V-representation can be processed as an
      H-representation
      and vice-versa (this is an application of duality). Hence facet
      estimates for a V-representation can also be obtained by running
      the
      problem as an H-representation with
      the estimates option. The estimated number of vertices will be in
      this
      case
      be an unbiased estimate for the number of facets for the original
      problem.&nbsp; <br>
      <font color="#000000">Since the origin is an interior point, the
        estimated number of vertices is an accurate estimate of the
        number of
        facets of the H-representation of the cube.&nbsp;&nbsp;
        Similarly,
        estimates for an input&nbsp; H-representation of a polytope
        containing
        the origin
        may be obtained by processing the file as a V-representation.
        The
        output
        will be essentially the same, but the number of bases computed
        may be
        very
        different, see the subsection <a
          href="#H-%20vs%20V-%20representation">H-
          vs
          V-representation.</a> </font>&nbsp; For a large problem
      of this type, it is useful to get estimates for the number of
      bases
      that <i>lrs</i> will compute for both V- and H-representations,
      so
      that simpler
      problem can be chosen.
      <p>The estimates may also be used to judge the feasibility of
        solving
        the problem using other codes. For example, any code that uses
        triangulation/perturbation to resolve degeneracy will have
        trouble if
        the number of bases is huge. Codes which must store all the
        output in
        memory (currently all codes except reverse search methods such
        as <i>lrs</i>)
        will
        have trouble if the estimated output size is huge.</p>
    </ul>
    <hr style="width: 100%; height: 2px;">
    <h3><a name="fourier"></a> Fourier Elimination<span style="color:
        rgb(204, 0, 0);"> (Due to several bug reports, this
        program should not be used. Caveat emptor!)</span><br>
    </h3>
    <div style="margin-left: 40px;">Tallman Nkgau has contributed a
      driver <span style="font-style: italic;">fourier</span> that
      computes the
      projection of a polyhedron given by its H-representation onto a
      selected set of coordinates. The program can be compiled by<br>
      <br>
      <span style="color: rgb(0, 0, 153);">make fourier<br>
        <br>
      </span>and is run by the command<span style="color: rgb(0, 0,
        153);"><br>
        <br>
        fourier file.ine [fileout]<br>
        <br>
        file.ine</span> is a standard H-representation that <span
        style="color: rgb(153, 0, 0);">does not contain linearities</span>.
      If
      you have linearities, please replace each by two inequalities.<br>
      Following the end statement, insert the option:<br>
      <br>
      <b><font color="#000066">project t&nbsp;</font><font
          color="#000099">
          a<sub>1 </sub>... a<sub>t<br>
            <br>
          </sub></font></b><sub>The output will be the polyhedron
        projected onto
        the coordinates</sub><b><font color="#000099"><sub> </sub></font></b><font
        color="#000099">a<sub>1 </sub>... a<sub>t&nbsp;</sub></font><sub>
        ,
        each of which is a unique number betwen 1 and n.</sub><font
        color="#000099"><sub><br>
        </sub></font></div>
    <ul>
    </ul>
    <br>
    <hr style="width: 100%; height: 2px;">
    <h3><a name="nash"></a> Nash
Equilibria&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      <span style="color: rgb(153, 0, 0);">New in Version
4.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Revised
        2009.2.18<br>
      </span></h3>
    <span style="color: rgb(153, 0, 0);">See: &nbsp;&nbsp; </span>D.
    Avis, G. Rosenberg, R. Savani, B. von Stengel, "<span
      style="font-style: italic;">Enumeration of Nash Equilibria for
      Two-Player Games</span>", <span style="font-weight: bold;">Economic

      Theory</span> 42(2009) 9-37&nbsp; <a
      href="http://cgm.cs.mcgill.ca/%7Eavis/doc/avis/ARSS09a.pdf">pdf</a><br>
    <br>
    <div style="margin-left: 40px;">All Nash equilibria (NE) for a two
      person noncooperative game are computed using two interleaved
      reverse
      search vertex enumeration steps.<br>
      The input for the problem are two m by n matrices A,B of integers
      or
      rationals. The first player is the row player, the second is the
      column
      player.<br>
      If row i and column j are played, player 1 receives A<sub>i,j</sub>
      and
      player 2 receives B<sub>i,j</sub>. <br>
      If you have two or more cpus available run <span style="color:
        rgb(204, 0, 0);">2nash</span> instead of <span style="color:
        rgb(204, 0, 0);">nash</span> as the order of the input
      games is immaterial.<br>
      It runs in parallel with the games in each order. <span
        style="color: rgb(204, 0, 0);">(If you use nash, the program
        usually runs faster if m is &lt;= n , see below.)</span><br
        style="color: rgb(204, 0, 0);">
      <br>
      The easiest way to use the program <span style="color: rgb(0, 0,
        153);">nash</span>
      or <span style="color: rgb(0, 0, 153);">2nash</span> is to first
      run <span style="color: rgb(0, 0, 153);">setupnash</span>
      or <span style="color: rgb(0, 0, 153);">( setupnash2</span> see
      below
      ) on a
      file containing:<br>
      &nbsp;m n <br>
      matrix A<br>
      matrix B<br>
      <br>
      eg. the file game is for a game with m=3 n=2:<br>
      3 2<br>
      <br>
      0 6<br>
      2 5<br>
      3 3<br>
      <br>
      1 0<br>
      0 2<br>
      4 3<br>
      <br>
      % setupnash game game1 game2&nbsp;&nbsp;&nbsp;&nbsp; <br>
      <br>
      produces two H-representations, game1 and game2, one for each
      player.<br>
      <br>
      To get the equilibrium, run<br>
      <br>
      % nash game1 game2<br>
      <br>
      or <br>
      <br>
      % 2nash game1 game2<br>
      <br>
      <br>
      <hr style="width: 100%; height: 2px;"><br>
      *nash:lrslib v.4.2b, 2006.10.11(32bit,lrsmp.h)<br>
      <br>
      ***** 5 4 rational<br>
      2&nbsp; 1/3&nbsp; 2/3&nbsp; 4 <br>
      1&nbsp; 2/3&nbsp; 1/3&nbsp; 0&nbsp; 2/3 <br>
      <br>
      2&nbsp; 2/3&nbsp; 1/3&nbsp; 3 <br>
      1&nbsp; 0&nbsp; 1/3&nbsp; 2/3&nbsp; 8/3 <br>
      <br>
      2&nbsp; 1&nbsp; 0&nbsp; 3 <br>
      1&nbsp; 0&nbsp; 0&nbsp; 1&nbsp; 4 <br>
      <br>
      *Number of equilibria found: 3<br>
      <hr style="width: 100%; height: 2px;"><br>
      Each row beginning 1 is a strategy for the row player yielding a
      NE
      with each row beginning 2 listed immediately above it.<br>
      The payoff for player 2 is the last number on the line beginning
      1, and
      vice versa. <br>
      Eg: first two lines of output: player 1 uses row probabilities 2/3
      2/3
      0 resulting in a payoff of 2/3 to player 2.<br>
      Player 2 uses column probabilities 1/3 2/3 yielding a payoff of 4
      to
      player 1.<br>
      <hr style="width: 100%; height: 2px;"><br>
      If <span style="color: rgb(153, 0, 0);">both</span> matrices are
      <span style="color: rgb(153, 0, 0);">nonnegative</span> and have <span
        style="color: rgb(153, 0, 0);">no zero columns</span>, you may
      instead
      use <span style="color: rgb(0, 0, 153);">setupnash2</span>:<br>
      <br>
      % setupnash2 game game1 game2<br>
      <br>
      Now the polyhedra produced are polytopes. <br>
      <br>
      The output&nbsp; of nash in this case is a list of unscaled
      probability
      vectors x and y.<br>
      <br>
      ----------------------------------------------------------<br>
      *nash:lrslib v.4.2b, 2006.10.11(32bit,lrsmp.h)<br>
      <br>
      ***** 4 3 rational<br>
      2&nbsp; 1/12&nbsp; 1/6 <br>
      1&nbsp; 1&nbsp; 1/2&nbsp; 0 <br>
      <br>
      2&nbsp; 2/9&nbsp; 1/9 <br>
      1&nbsp; 0&nbsp; 1/8&nbsp; 1/4 <br>
      <br>
      2&nbsp; 1/3&nbsp; 0 <br>
      1&nbsp; 0&nbsp; 0&nbsp; 1/4 <br>
      <br>
      *Number of equilibria found: 3<br>
      -----------------------------------------------------------<br>
      <br>
      <br>
      To normalize, divide each vector by v = 1^T x and u=1^T y.<br>
      u and v are the payoffs to players 1 and 2 respectively.<br>
      <br>
      In this case, lower bounds on the payoff functions to either or
      both
      players may be included. <br>
      To give a lower bound of r on the payoff for player 1 add the
      options
      to file game2&nbsp; (yes that is correct!)<br>
      To give a lower bound of r on the payoff for player 2 add the
      options
      to file game1 <br>
      <br>
      <span style="color: rgb(0, 0, 153);"></span><span style="color:
        rgb(0, 0, 153);">minimize 0 1 1 ... 1 &nbsp; &nbsp;</span>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;
&nbsp;
(n
      entries to be given)<br>
      <span style="color: rgb(0, 0, 153);">bound &nbsp; 1/ r</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(
note:
      reciprocal of r)<br>
      <br>
      <hr style="width: 100%; height: 2px;"><span style="color: rgb(153,
        0, 0);">If you do not wish to use the 2-cpu
        program 2nash, please read the following.<br>
        <br>
      </span>If m is greater than n then <span style="color: rgb(153,
        0, 0);">nash</span>
      usually runs faster by transposing the players. This is
      achieved by running:<br>
      <br>
      % nash game2 game1<br>
      <br>
      If you wish to construct the game1 and game2 files by hand, they
      are
      fragile and should be done exactly as follows:<br>
      <br>
      &nbsp;&nbsp; For player 1: eg. game1<br>
      &nbsp;&nbsp; One linearity in the last row<br>
      &nbsp;&nbsp; Identity matrix with additional final column 0<br>
      &nbsp;&nbsp; Transpose of payoff matrix for player 2 with final
      column 1<br>
      &nbsp;&nbsp; Last row is prob sum to one<br>
      <br>
      &nbsp;&nbsp; For player 2: eg. game2<br>
      &nbsp;&nbsp; One linearity in the last row<br>
      &nbsp;&nbsp; Payoff matrix for player 1 with final column 1<br>
      &nbsp;&nbsp; Identity matrix with additional final column 0<br>
      &nbsp;&nbsp; Last row is prob sum to one<br>
      <br>
      Corresponding to file game above we get<br>
      <hr style="width: 100%; height: 2px;">*game: player 1<br>
      H-representation<br>
      linearity 1 6<br>
      begin<br>
      6 5 rational<br>
      0 1 0 0 0 <br>
      0 0 1 0 0 <br>
      0 0 0 1 0 <br>
      0 -1 0 -4&nbsp; 1 <br>
      0 0 -2 -3&nbsp; 1 <br>
      -1 1 1 1 0 <br>
      end<br>
      <hr style="width: 100%; height: 2px;">*game: player 2<br>
      H-representation<br>
      linearity 1 6<br>
      begin<br>
      6 4 rational<br>
      0 0 -6&nbsp; 1 <br>
      0 -2 -5&nbsp; 1 <br>
      0 -3 -3&nbsp; 1 <br>
      0 1 0 0 <br>
      0 0 1 0 <br>
      -1 1 1 0 <br>
      end<br>
      <br>
    </div>
    <br>
    <br>
    <hr style="width: 100%; height: 2px;"><br>
    <h3> &nbsp;<a name="Linear Programming"></a> Linear
Programming&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      <span style="color: rgb(153, 51, 0); font-weight: normal;">(
        Revised
        V4.2)</span></h3>
    <ul>
      <i>lrs</i> can be used to solve linear programming
      problems in rational arithmetic when the input is an
      H-representation.&nbsp;
      Use the option:
    </ul>
    <b><font color="#000066">lponly</font></b>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
and
one
      of the options maximize or minize: </p>
    <p><b><font color="#000066">maximize </font><font color="#000099">
          a<sub>0</sub>
          a<sub>1 </sub>... a<sub>n-1</sub></font></b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
H-representation&nbsp;
      only // </p>
    <ul>
      &nbsp;simply maximizes the function&nbsp; a<sub>0</sub> + a<sub>1
      </sub>x<sub>
        1 </sub>+ ... + a<sub>n-1</sub> x<sub>n-1</sub> <br>
      &nbsp;over the given polyhedron. A optimal vertex is given when it
      exists, otherwise for unbounded solutions a vertex and ray is
      given. A
      minimization will be performed if the&nbsp; following option is
      specified:
    </ul>
    <b><font color="#000066">minimize </font><font color="#000099">a<sub>0</sub>
        a<sub>1 </sub>... a<sub>n-1</sub></font></b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
H-representation&nbsp;
    only //
    <p>To print the dictionary at a few key points also include the
      option:
    </p>
    <p><b><font color="#000066">verbose<br>
        </font></b></p>
    <p><b><font color="#000066"><span style="color: rgb(153, 51, 0);">New
in
            V4.2.</span> </font></b>Dual variables are now printed at
      termination. If the linearity option is used, only a partial list
      of
      dual variables will be given.<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Dual
variable
      y<sub>i</sub> refers to inequality number i in the input.<br>
    </p>
    <p> </p>
    <hr width="100%">
    <ul>
      &nbsp;
    </ul>
    <h3> <a name="Volume Computation"></a> Volume and Triangulation<br>
    </h3>
    <i>lrs</i> can be used to compute the volume of a <font
      color="#990000">full
      dimensional</font> polytope given as a V-representation. This
    follows
    from the fact that lex-postive bases form a triangulation
    of the facets, and that a V-representation is always lifted. See
    "Theoretical Description" on lrs home page for some remarks on this.
    The option
    <p><b><font color="#000099">volume&nbsp;</font>&nbsp;&nbsp;&nbsp;</b>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
V-representation
      only // </p>
    <p>will cause the volume to be computed. For input cube.ext, the
      output
      is: <br>
      <b style="color: rgb(153, 0, 0);">*Volume=8</b><br>
    </p>
    <p>The triangulation can be output by adding also the option <span
        style="color: rgb(0, 0, 153); font-weight: bold;">verbose</span>.<br>
      This would give the output:<br>
    </p>
    <p><span style="color: rgb(153, 0, 0); font-weight: bold;">F#0 B#1
        h=0
        vertices/rays&nbsp; 4 6 7 8 I#8 det= 8 </span><br style="color:
        rgb(153, 0, 0); font-weight: bold;">
      <span style="color: rgb(153, 0, 0); font-weight: bold;">&nbsp;1&nbsp;
1&nbsp;
        0&nbsp; 0 </span><br style="color: rgb(153, 0, 0); font-weight:
        bold;">
      <span style="color: rgb(153, 0, 0); font-weight: bold;">&nbsp;1&nbsp;
0&nbsp;
        1&nbsp; 0 </span><br style="color: rgb(153, 0, 0); font-weight:
        bold;">
      <span style="color: rgb(153, 0, 0); font-weight: bold;">&nbsp;1&nbsp;
0&nbsp;
        0&nbsp; 1 </span><br style="color: rgb(153, 0, 0); font-weight:
        bold;">
      <span style="color: rgb(153, 0, 0); font-weight: bold;">F#3 B#2
        h=1
        vertices/rays&nbsp; 4 5 6 7 I#8 det= 8 </span><br style="color:
        rgb(153, 0, 0); font-weight: bold;">
      <span style="color: rgb(153, 0, 0); font-weight: bold;">F#3 B#3
        h=2
        vertices/rays&nbsp; 3 4 5 7 I#8 det= 8 </span><br style="color:
        rgb(153, 0, 0); font-weight: bold;">
      <span style="color: rgb(153, 0, 0); font-weight: bold;">&nbsp;1
        -1&nbsp; 0&nbsp; 0 </span><br style="color: rgb(153, 0, 0);
        font-weight: bold;">
      <span style="color: rgb(153, 0, 0); font-weight: bold;">F#4 B#4
        h=3
        vertices/rays&nbsp; 2 3 4 5 I#8 det= 8 </span><br style="color:
        rgb(153, 0, 0); font-weight: bold;">
      <span style="color: rgb(153, 0, 0); font-weight: bold;">&nbsp;1&nbsp;
0&nbsp;
        0 -1 </span><br style="color: rgb(153, 0, 0); font-weight:
        bold;">
      <span style="color: rgb(153, 0, 0); font-weight: bold;">F#5 B#5
        h=4
        vertices/rays&nbsp; 1 2 3 5 I#8 det= 8 </span><br style="color:
        rgb(153, 0, 0); font-weight: bold;">
      <span style="color: rgb(153, 0, 0); font-weight: bold;">F#5 B#6
        h=2
        vertices/rays&nbsp; 2 4 5 6 I#8 det= 8 </span><br style="color:
        rgb(153, 0, 0); font-weight: bold;">
      <span style="color: rgb(153, 0, 0); font-weight: bold;">&nbsp;1&nbsp;
        0
        -1&nbsp; 0 </span><br style="color: rgb(153, 0, 0);
        font-weight: bold;">
      <span style="color: rgb(153, 0, 0); font-weight: bold;">end</span><br
        style="color: rgb(153, 0, 0); font-weight: bold;">
      <span style="color: rgb(153, 0, 0); font-weight: bold;">*Sum of
        det(B)=
        48 </span><br style="color: rgb(153, 0, 0); font-weight: bold;">
      <span style="color: rgb(153, 0, 0); font-weight: bold;">*Volume= 8
      </span><br style="color: rgb(153, 0, 0);">
    </p>
    <p>Each of the 6 bases corresponds to a simplex. <br>
      The first simplex is composed of vertices 4 6 7 8, second simplex
      is 4
      5 6 7, etc.<br>
    </p>
    <p>If the <font color="#000099"><b>volume</b> </font>option is
      applied
      to an H-representation, the results are not predictable. If the
      option
      is
      applied to a V-representation of &nbsp;a polytope that is not full
      dimensional, the volume of a projected polytope is computed. The
      projection used is to the lexicographically smallest coordinate
      subspace, see <a
        href="http://cgm.cs.mcgill.ca/%7Eavis/doc/avis/AFP02a.ps">Avis,
        Fukuda, Picozzi
        (2002)</a>.&nbsp; </p>
    <p>For polytopes given by a H-representation, it will first be
      necessary to
      compute the V-representation. <br>
    </p>
    <hr width="100%"><a name="Voronoi Diagrams"></a>
    <h3> Voronoi Diagrams</h3>
    <i>lrs</i> can be used the compute the V-vertices of a Voronoi
    diagram
    of a set of data points in n-1 dimensional space. To do this we use
    a
    standard lifting procedure (see, e.g., Edelsbrunner, "Algorithms in
    Combinatorial Geometry," pp 296-297) . Each point is mapped to a
    half
    space tangent to the parabaloid in n dimensions, by the mapping:
    <p>p<sub>1&nbsp;</sub> , p<sub>2&nbsp;</sub> , ...., p<sub> n-1</sub>&nbsp;&nbsp;&nbsp;&nbsp;
      -&gt;&nbsp;&nbsp;&nbsp;
      (p<sub>1 </sub><sup> 2&nbsp; </sup>+&nbsp;&nbsp;
      p<sub>2</sub><sup>2 </sup>+&nbsp; ...&nbsp;&nbsp; +&nbsp; p<sub>n-1</sub><sup>2&nbsp;</sup>
      ) - 2 p<sub>1</sub>&nbsp; x<sub> 1&nbsp;</sub> - 2 p<sub>2&nbsp;</sub>
      x<sub>2
      </sub>- .... - 2&nbsp; p<sub> n-1 </sub>x<sub>n -1&nbsp;</sub> +
      x <sub>n</sub>&gt;=
      0
    </p>
    <p><i>lrs</i> is applied to the H-representation so created.&nbsp;
      This
      transformation is performed automatically for a V-representation
      if the
    </p>
    <p><b><font color="#000099">voronoi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        </font></b>// V-representation only - <font color="#990000">place
immediately
        after end statement</font> // </p>
    <p>option is specified. <br>
      <b>Note</b>: The input file must consist entirely of
      data points (no rays), i.e.. there must be a one in column one of
      each
      line. The <b><font color="#000099">volume </font></b>option
      should not be used, since the volume reported will not be the
      volume of
      the original V-representation. <br>
      The output will consist of the Voronoi vertices (columns beginning
      with
      a one) and Voronoi rays (columns beginning with zero) for the
      Voronoi
      diagram defined on the data points.&nbsp; If the <b><font
          color="#000099">printcobasis</font></b> option is given, the n
      "<b><font color="#ff0000">data points</font></b>" indices produced
      will tell
      which set of input data points corresponds to the given Voronoi
      vertex
      or ray. In case of degeneracies, a given Voronoi vertex may be
      generated by more than n of the input data points. In this case,
      use of
      the <b><font color="#000099">allbases</font></b> option will
      cause
      all&nbsp; sets of n input data points corresponding to a Voronoi
      vertex
      to be printed. For Voronoi rays, the immediately preceding&nbsp;
      cobasis is
      the cobasis of the the Voronoi vertex from which the ray
      emanates.&nbsp; The
      index followed by a <b><font color="#ff0000">* </font></b><font
        color="#000000">is</font> the data point to drop in order to
      generate
      the ray. If the <b><font color="#000099"> geometric </font></b>option
is
      given the correspondence between Voronoi rays and Voronoi vertices
      will be produced automatically. </p>
    <p><b><font color="#000000">Example:</font></b> Compute the Voronoi
      diagram of the planar point set (0,0), (2,1), (1,2), (0,4), (4,0),
      (4,4) (2,-4). <br>
      <b><font color="#000099">vor7-3</font></b> <br>
      <b><font color="#000099">*6 Voronoi vertices and 5 rays</font></b>
      <br>
      <b><font color="#000099">*7 input data points</font></b> <br>
      <b><font color="#000099">V-representation</font></b>
      <br>
      <b><font color="#000099">begin</font></b> <br>
      <b><font color="#000099">7 3 integer</font></b> <br>
      <b><font color="#000099">1 0 0</font></b> <br>
      <b><font color="#000099">1 2 1</font></b> <br>
      <b><font color="#000099">1 1 2</font></b> <br>
      <b><font color="#000099">1 0 4</font></b> <br>
      <b><font color="#000099">1 4 0</font></b> <br>
      <b><font color="#000099">1 4 4</font></b> <br>
      <b><font color="#000099">1 2 -4</font></b> <br>
      <b><font color="#000099">end</font></b> <br>
      <b><font color="#000099">voronoi</font></b> <br>
      <b><font color="#000099">printcobasis</font></b> <br>
      <b><font color="#000099">allbases</font></b> <br>
      <b><font color="#000099">geometric</font></b> </p>
    <p><font color="#000000">The output produced is</font> <br>
      &nbsp; </p>
    <p><b><font color="#ff0000">V-representation</font></b> <br>
      <b><font color="#ff0000">begin</font></b> <br>
      <b><font color="#ff0000">***** 3 rational</font></b>
      <br>
      <b><font color="#ff0000">V#1 R#0 B#1 h=0 data points&nbsp; 1 5 7
          det=64</font></b>
      <br>
      <b><font color="#ff0000">1 2 -3/2</font></b> <br>
      <b><font color="#ff0000">V#1 R#1 B#1 h=0 data points&nbsp; 1 5* 7
          det=64</font></b>
      <br>
      <b><font color="#ff0000">0 -2 -1&nbsp; * 1 2 -3/2</font></b> <br>
      <b><font color="#ff0000">V#1 R#2 B#1 h=0 data points&nbsp; 1* 5 7
          det=64</font></b>
      <br>
      <b><font color="#ff0000">0 2 -1&nbsp; * 1 2 -3/2</font></b> <br>
      <b><font color="#ff0000">V#1 R#2 B#2 h=1 data points&nbsp; 1 2 5
          det=16</font></b>
      <br>
      <b><font color="#ff0000">1 2 -3/2</font></b> <br>
      <b><font color="#ff0000">V#2 R#2 B#3 h=2 data points&nbsp; 1 2 3
          det=12</font></b>
      <br>
      <b><font color="#ff0000">1 5/6 5/6</font></b> <br>
      <b><font color="#ff0000">V#3 R#2 B#4 h=3 data points&nbsp; 1 3 4
          det=16</font></b>
      <br>
      <b><font color="#ff0000">1 -3/2 2</font></b> <br>
      <b><font color="#ff0000">V#3 R#3 B#4 h=3 data points&nbsp; 1 3* 4
          det=16</font></b>
      <br>
      <b><font color="#ff0000">0 -1 0&nbsp; * 1 -3/2 2</font></b> <br>
      <b><font color="#ff0000">V#4 R#3 B#5 h=2 data points&nbsp; 2 5 6
          det=32</font></b>
      <br>
      <b><font color="#ff0000">1 15/4 2</font></b> <br>
      <b><font color="#ff0000">V#4 R#4 B#5 h=2 data points&nbsp; 2* 5 6
          det=32</font></b>
      <br>
      <b><font color="#ff0000">0 1 0&nbsp; * 1 15/4 2</font></b> <br>
      <b><font color="#ff0000">V#5 R#4 B#6 h=3 data points&nbsp; 2 3 6
          det=20</font></b>
      <br>
      <b><font color="#ff0000">1 27/10 27/10</font></b> <br>
      <b><font color="#ff0000">V#6 R#4 B#7 h=4 data points&nbsp; 3 4 6
          det=32</font></b>
      <br>
      <b><font color="#ff0000">1 2 15/4</font></b> <br>
      <b><font color="#ff0000">V#6 R#5 B#7 h=4 data points&nbsp; 3* 4 6
          det=32</font></b>
      <br>
      <b><font color="#ff0000">0 0 1&nbsp; * 1 2 15/4</font></b> <br>
      <b><font color="#ff0000">end</font></b> </p>
    <p><font color="#000000">The output contains 6 Voronoi vertices :</font>
      <br>
      <font color="#000000">(2, -3/2), (5/6,5/6),(-3/2,2),(15/4,2),
        (27/10,27/10), (2,15/4).</font> <br>
      <font color="#000000">The Voronoi vertex (2,-3/2) appears twice in
        the
        output with data point indices 1 5 7 and 1 2 5. This means
        that it is degenerate and is defined by the set of 4 input data
        point
        in
        positions 1,2,5,7 in the input file. I.e.. it is the centre of
        an
        empty&nbsp;
        circle through the four input data points </font>(0,0), (2,1),
      4,0),
      (2,-4).&nbsp; The other Voronoi vertices appear once each and are
      defined respectively by the data points <font color="#000000">with
indices
        (i.e..&nbsp; position in the input file)&nbsp; 1 2 3,&nbsp; 1 3
        4,&nbsp; 2 5 6,&nbsp; 2 3 6 and 3 4 6. The&nbsp; Voronoi diagram
        has 5
        rays</font> <br>
      <font color="#000000">(2, -3/2) + (-2t,-t),&nbsp;&nbsp;&nbsp;
        (2,-3/2)+(2t,-t),&nbsp;&nbsp;&nbsp;
        (-3/2,2)+(-t,0),&nbsp;&nbsp;&nbsp;
        (15/4,2)+(t,0),&nbsp;&nbsp;&nbsp; (2,15/4)+(0,t)</font> </p>
    <p><font color="#000000">For example, the first ray in the output
        appears:</font> <br>
      <b><font color="#ff0000">V#1 R#1 B#1 h=0 data points&nbsp; 1 5* 7
          det=64</font></b>
      <br>
      <b><font color="#ff0000">0 -2 -1&nbsp; * 1 2 -3/2</font></b> <br>
      <font color="#000000">&nbsp;This means that the ray (-2t,-t)
        emanates
        from the vertex defined by data points 1 5 7, namely (2, -3/2).
        The
        asterisk on index 5 indicates that the ray is defined by the
        data
        points with indices 5 and 7, namely (0,0) and (2,-4).</font> <br>
      &nbsp; <br>
      &nbsp; </p>
    <h3>
      <hr width="100%">&nbsp;<a name="Extreme Point Enumeration and
        Redundant Inequalities"></a>
      Extreme Point Enumeration and Redundant Inequalities</h3>
    A convex hull problem that occurs frequently is to enumerate the
    extreme points (vertices) of a given set of input points. This
    problem
    is in fact much simpler than the problem of finding the facets of
    the
    given input point set. It can be solved by linear programming.&nbsp;
    The dual problem is to remove redundant inequalities from an
    H-representation. An input&nbsp; inequality is redundant if it can
    be
    deleted without changing the polyhedron. The program <i>redund </i>also
solves
these
    problems. They can be solved by <i>cdd </i>using the
    vertex_listing&nbsp; and facet_listing&nbsp; options.
    <p>To remove input points that are not vertices from a
      V-representation
      or redundant inequalities from an H-representation use the
      command: </p>
    <ul>
      <b><font color="#000099">redund filename</font></b>
    </ul>
    <font color="#000000">The resulting file can be used directly with
      lrs,
      or even piped into lrs. In fact, lrs works best if the input is
      non-redundant, see the section <a href="#Hints%20and%20Comments">Redundancy
        vs
        Degeneracy.</a> </font>
    <p>Note: Versions of redund prior to this release failed to remove
      redundancy from the starting basis. </p>
    <hr width="100%">
    <h2> <a name="Linearities"></a>Linearities&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(New
in
      Version 4.0)</h2>
    <p><br>
      <b><font color="#000066">linearity&nbsp; k&nbsp; i<sub>1 </sub>i<sub>2
          </sub>i ... i<sub>k</sub></font></b> </p>
    <blockquote>The input file contains k linearities. If the input is a
      H-representation, the rows <b><font color="#000066">i<sub>1 </sub>
          i<sub>2 </sub>i ... i<sub>k </sub></font></b>of the input
      file are
      equations. For a V-representation, the rows with these indices
      should
      begin with zero in column one, and will be interpreted as lines
      rather
      than rays.&nbsp; Linearities defined on the input vertices of a
      V-representation are not defined, but the program will accept them
      and
      produce some output. Each of the indice <b><font color="#000099">i<sub>k</sub></font></b>
      must be a distinct number between <b><font color="#000099">1</font></b>
      and <b><font color="#000099"> m</font></b>. With an&nbsp;
      H-representation, linearities are useful for enumeration of
      vertices on
      a facet or lower dimensional subspace. For example the file:
      <p><b><font color="#000099">cube_ridge</font></b> <br>
        <b><font color="#000099">*cube of side 2 centred at the origin</font></b>
        <br>
        <b><font color="#000099">H-representation</font></b> <br>
        <b><font color="#000099">linearity 2&nbsp; 1 5</font></b> <br>
        <b><font color="#000099">begin</font></b> <br>
        <b><font color="#000099">6 4 rational</font></b> <br>
        <b><font color="#000099">1 1 0 0</font></b> <br>
        <b><font color="#000099">1 0 1 0</font></b> <br>
        <b><font color="#000099">1 0 0 1</font></b> <br>
        <b><font color="#000099">1 -1 0 0</font></b> <br>
        <b><font color="#000099">1 0 -1 0</font></b> <br>
        <b><font color="#000099">1 0 0 -1</font></b> <br>
        <b><font color="#000099">end</font></b> </p>
      <p><font color="#000000">causes vertices to be enumerated on the
          ridge which
          is the intersection of the two facets</font> </p>
      <p><font color="#000000">x<sub>1</sub> = -1&nbsp;&nbsp;
          and&nbsp;&nbsp; x<sub>2</sub> = 1</font> </p>
      <p><font color="#000000">so the output is the pair of vertices</font>
      </p>
      <p><font color="#cc0000">cube_ridge</font> <br>
        <font color="#cc0000">*Input linearity in row(s) 1
          5</font> <br>
        <font color="#cc0000">V-representation</font> <br>
        <font color="#cc0000">begin</font> <br>
        <font color="#cc0000">2&nbsp; 4&nbsp; rational</font> <br>
        <font color="#cc0000">&nbsp;1 -1&nbsp; 1&nbsp; 1</font> <br>
        <font color="#cc0000">&nbsp;1 -1&nbsp; 1 -1</font> <br>
        <font color="#cc0000">end</font> </p>
      <p>Specifying linearities in this way will often produce <a
          href="#Extreme%20Point%20Enumeration%20and%20Redundant%20Inequalities">
          redundancy</a> , especially if the dimension of the problem is
        reduced
        considerably.
        As a preprocessing step, it is useful to apply to remove any
        redundancy
        by <i> redund</i>. In the case of the above problem the output
        produced by<i> redund</i> is: </p>
      <p><font color="#cc0000">cube</font> <br>
        <font color="#cc0000">*Input linearity in row(s) 1
          5</font> <br>
        <font color="#cc0000">*row 2 was redundant and removed</font> <br>
        <font color="#cc0000">*row 4 was redundant and removed</font> <br>
        <font color="#cc0000">H-representation</font> <br>
        <font color="#cc0000">linearity 2 1 2</font> <br>
        <font color="#cc0000">begin</font> <br>
        <font color="#cc0000">4 4 rational</font> <br>
        <font color="#cc0000">&nbsp;1&nbsp; 1&nbsp; 0&nbsp; 0</font> <br>
        <font color="#cc0000">&nbsp;1&nbsp; 0 -1&nbsp; 0</font> <br>
        <font color="#cc0000">&nbsp;1&nbsp; 0&nbsp; 0&nbsp; 1</font> <br>
        <font color="#cc0000">&nbsp;1&nbsp; 0&nbsp; 0 -1</font> </p>
      <p><font color="#000000">and two redundant halfspaces were
          removed.</font> </p>
      <p><font color="#000000">Redundant columns are closely related to
          linearities. If we examine the V-representation of cube_ridge
          above we
          can see that it is just a line segment in 3 dimensional space.
          Further,&nbsp; columns 2 and 3 are multiples of column 1. If
          lrs is
          applied to this file, the column redundancies give rise to two
          linearities, so the output will appear as the H-representation
          given
          above: geometrically the intersection of two planes (the
          linearities)
          with two half-planes (defining the endpoints of the line
          segment).</font> </p>
      <p><font color="#000000">In general, the representation of the
          linearity space is not unique, however the one produced by lrs
          should
          be the same as that produced by cdd.</font></p>
    </blockquote>
    <p><br>
    </p>
    <hr width="100%">
    <h3> <a name="Timing and Interrupts"></a> Timing and Interrupts</h3>
    <i>lrs</i> handles certain signals unless it is compiled with the
    -DOMIT_SIGNALS option. It is possible to interrupt <i>lrs</i> and
    get
    the latest cobasis, which can be used for restarting the program
    (useful if the machine is going down!) <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>signal&nbsp;</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <b>operation</b> <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    USR1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
print
current
    cobasis and continue <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    TERM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
print
current
    cobasis and terminate <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INT
(ctrl-C)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    ditto
    <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
HUP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    ditto
    <br>
    <i>lrs</i> also provides timing information, unless compiled with
    the
    option -DOMIT_TIMES. <br>
    <hr width="100%">
    <h3> <a name="Error Messages"></a> Error Messages and
      Troubleshooting</h3>
    The most common error occurs from an incorrect input file
    specification, please check the section <a href="#File%20Formats">File
Formats
    </a> carefully. In particular, <i>lrs</i> does not check the
    type or number of input coefficients specified.&nbsp; After the line
    <br>
    <b><font color="#000099">m n rational</font></b> <br>
    <font color="#000000">you must specify <b>exactly</b> m*n rational
      or
      integer coefficients. They are read&nbsp; in <b>free format</b> ,
      but
      normally each input facet or vertex/ray is begun on a new
      line.&nbsp;
      See <a href="#Note%20for%20cdd%20users">note for cdd users.</a> </font>
    <p>The following error messages are produced by <i>lrs</i> . They
      are&nbsp; arranged in alphabetic order. </p>
    <p><b><font color="#ff0000">Data type must be integer of rational</font></b>
    </p>
    <ul>
      <font color="#000000"><i>lrs</i> does not handle
        floating point data, change to integer or rational input.</font>
    </ul>
    <b><font color="#ff0000">Digits must be at most 2295&nbsp; Change
        MAX_DIGITS and recompile</font></b>
    <ul>
      <font color="#000000">The digits option was specified, but the
        number
        of&nbsp; decimal digits is too large (the values shown here is
        for 64
        bit machines). MAX_DIGITS&nbsp; (default 255) is the maximum
        number of array locations used for extended precision
        arithmetic. This
        value should be increased&nbsp; and <i>lrs</i> recompiled.</font>
    </ul>
    <b><font color="#ff0000">Input Polyhedron does not have full
        dimension</font></b>
    <br>
    <b><font color="#ff0000">If input is a cone, change to
        H-representation, or add the origin 1 0 0 ... 0</font></b>
    <ul>
      <font color="#000000">The input polyhedron does not have dimension
        n-1. Either there is a mistake in the input, or it must be
        projected
        onto a full dimensional subspace. <i><a
            href="http://www.ifor.math.ethz.ch/staff/fukuda/cdd_home/cdd.html">
            cdd</a> </i> has a function for doing this. The second
        message only appears
        for V-representations - note that at least one vertex must
        be supplied, or else the problem can be run as a
        H-representation.</font>
    </ul>
    <font color="#ff0000"><b>Invalid Co-bas</b>is - does not have
      correct
      rank</font>
    <ul>
      <font color="#000000">An attempt to restart from
        an invalid cobasis has been made. Check that the indices are
        entered
        exactly as they appear in the previous aborted run.</font>
    </ul>
    <b><font color="#ff0000">Maximize/minimize only valid for
        H-representation</font></b>
    <ul>
      <font color="#000000">LP operations can only be performed on
        H-representations.</font>
    </ul>
    <b><font color="#ff0000">No begin line</font></b>
    <ul>
      <font color="#000000">Input file does not contain a begin line.
        See <a href="#File%20Formats">File Formats.</a> </font>
    </ul>
    <b><font color="#ff0000">No data in file</font></b>
    <ul>
      <font color="#000000">The input file is incorrect, please check <a
          href="#File%20Formats">File Formats.</a> </font>
    </ul>
    <b><font color="#ff0000">No feasible solution</font></b>
    <ul>
      <font color="#000000">The input is an H-representation of an
        infeasible system.</font>
    </ul>
    <b><font color="#ff0000">Starting cobasis indices must be distinct
        and
        in range 1 .. m</font></b>
    <ul>
      <font color="#000000">The startingcobasis option
        has been used, but the indices supplied were not valid: i.e.
        distinct
        numbers between 1..m.</font>
    </ul>
    <b><font color="#ff0000">Trying to restart from infeasible
        dictionary</font></b>
    <ul>
      <font color="#000000">An attempt to restart from
        an invalid cobasis has been made. Check that the indices are
        entered
        exactly&nbsp; in the order appear in the previous aborted run.</font>
    </ul>
    <h3>
      <hr width="100%"><a name="Hints and Comments"></a> <font
        color="#000000">Hints and Comments</font></h3>
    <h4> <a name="H- vs V- representation"></a> <font color="#000000">H-
vs
        V- representation</font></h4>
    <font color="#000000">&nbsp;<i>lrs</i> is programmed to manipulate
      H-representations directly. A file presented as a V-representation
      is
      processed by lifting it to a cone in one higher dimension, which
      is
      treated internally as a H-representation. If the input file is a
      polytope which contains the origin, then the user has two options.
      Submit it as a V-representation and have it processed as just
      described, or submit it as a H-representation, and interpret the
      output
      as a list of facet inequalities rather than "vertices". Since this
      will
      not be lifted, it will be processed in a different way by <i>lrs</i>.
      Sometimes a degenerate V-representation may run more quickly as a
      H-representation, and sometimes more slowly. To decide which
      representation to use for a large problem, the user can run the </font><b><font
        color="#3333ff">estimates</font></b><font color="#000000">
      option and
      choose the representation with fewest estimated bases.</font> <br>
    &nbsp;
    <h4> Redundancy vs Degeneracy</h4>
    For an H-representation, an input is redundant if some inequality
    can
    be deleted without changing the polyhedron. It is degenerate if (in
    d
    dimensions) at least one vertex lies on d+1 or more facets.&nbsp;
    Similarly in a V-representation an input is redundant if some input
    point is not a vertex of the convex hull.&nbsp; It is degenerate if
    some facet contains d+1 or more input points. The <a
      href="#Options">
      options</a> &nbsp; <b><font color="#000099">printcobasis</font></b>
    and <b><font color="#000099"> incidence</font></b> give degeneracy
    information. Degeneracy causes pivot&nbsp; or triangulation based
    methods such as<i> lrs </i>to&nbsp; run slowly. Redundancy is one
    cause of degeneracy, but it can be avoided by pre-processing the
    input
    files. See section <a
      href="#Extreme%20Point%20Enumeration%20and%20Redundant%20Inequalities">
      Extreme Point Enumeration and Redundant Inequalities</a> for
    instructions
    on how to do this. This pre-processing is unnecessary if it is known
    that
    the input is non-redundant.
    <p>Even with redundant input removed a polyhedron may be highly
      degenerate. In directory <a
        href="http://cgm.cs.mcgill.ca/%7Eavis/pub/C">ine/metric </a>
      there
      are many highly degenerate combinatorial polytopes. These are
      difficult
      problems for all vertex enumeration/convex hull programs that use
      pivoting, such as <i>lrs</i>.&nbsp; For example, the file <i>ccc7.ine</i>
      is a cone with 63 facets in 21 dimensions. It has 38,780 extreme
      rays,
      but computing these required the evaluation of 247,271,659 bases!
    </p>
    <h4> <font color="#000000">Memory considerations</font></h4>
    <font color="#000000">The strong point of <i>lrs</i> is that it
      does
      not save the output produced, so in theory it cannot run out of
      memory.&nbsp; With cache size one all memory is allocated at the
      beginning, so if <i>lrs</i> starts running it will not run out of
      memory. It is possible however that the number of digits required
      to do
      the calculations exceeds the amount specified on the </font><b><font
        color="#000099">digits</font></b><font color="#000000"> option,
      or the
      default. In practice, this problem will also arise early in the
      computation. In any case, a message is printed and the calculation
      can
      be restarted. In order to improve performance, some dictionaries
      should
      be cached. The default of 10 can be overridden by the </font><b><font
        color="#000099"> cache</font></b><font color="#000000">option.
      If the
      dictionary is in the cache it does not need to be recomputed when
      backtracking, reducing&nbsp; processing time by about 40%. Since
      the
      cache is allocated dynamically,
      a cache size that is too large can potentially use up large
      ammounts of
      machine memory.</font>
    <h4> Geometric Rays</h4>
    A minimum V-representation of a polyhedron is a minimum set of
    vertices
    and rays such that each point in the polyhedron can be expressed as
    a
    convex combination of vertices plus a non-negative combination of
    rays.
    For the cube, if we delete the inequality <br>
    x<sub>3</sub> &lt;= 1, i.e.. the line 1 0 0 -1 from file <i>cube.ine</i>,
    we
    get the output: <br>
    <b><font color="#ff0000">V-representation</font></b> <br>
    <b><font color="#ff0000">***** 4 rational</font></b> <br>
    <b><font color="#ff0000">1 1 1 -1</font></b> <br>
    <b><font color="#ff0000">0 0 0 1</font></b> <br>
    <b><font color="#ff0000">1 -1 1 -1</font></b> <br>
    <b><font color="#ff0000">1 1 -1 -1</font></b> <br>
    <b><font color="#ff0000">1 -1 -1 -1</font></b> <br>
    <b><font color="#ff0000">end</font></b> <br>
    indicating the polyhedron is the convex combination of 4 vertices
    and 1
    ray. With the <b><font color="#000099">geometric</font></b> option,
    we
    get the output: <br>
    <b><font color="#ff0000">V-representation</font></b> <br>
    <b><font color="#ff0000">begin</font></b> <br>
    <b><font color="#ff0000">***** 4 rational</font></b> <br>
    <b><font color="#ff0000">1 1 1 -1</font></b> <br>
    <b><font color="#ff0000">0 0 0 1&nbsp; * 1 1 1 -1</font></b> <br>
    <b><font color="#ff0000">1 -1 1 -1</font></b> <br>
    <b><font color="#ff0000">0 0 0 1&nbsp; * 1 -1 1 -1</font></b> <br>
    <b><font color="#ff0000">1 1 -1 -1</font></b> <br>
    <b><font color="#ff0000">0 0 0 1&nbsp; * 1 1 -1 -1</font></b> <br>
    <b><font color="#ff0000">1 -1 -1 -1</font></b> <br>
    <b><font color="#ff0000">0 0 0 1&nbsp; * 1 -1 -1 -1</font></b> <br>
    <b><font color="#ff0000">end</font></b> <br>
    This indicates that geometrically, the polyhedron has 4 parallel
    extreme rays (0,0,t) , one incident to each vertex. With the <b><font
        color="#000099"> geometric</font></b> option, all rays will be
    printed. Without
    the option, <i>lrs </i>tries to print each ray once, but
    in some cases duplicates will remain, see&nbsp; subsection Output
    Duplication.
    <br>
    <a name="Output Duplication"></a> <br>
    <b>Output Duplication</b>
    <p>For degenerate inputs, pivot based methods for vertex/ray
      enumeration such as <i> lrs</i> may
      generate the same output ray many times. An output is only
      printed when it occurs with a lexicographically minimum basis.
      This
      removes all duplicate vertices, but rays may still be output
      more than once. This is due to the fact that duplicate geometric
      rays
      cannot always be detected without storing the output. Since
      V-representations are automatically lifted to a higher dimension,
      this
      will not happen for facet enumeration. Unless the <b><font
          color="#000099">allbases </font></b>option is specified, <i>
        lrs</i>
      makes checks in order to remove duplicates.&nbsp;&nbsp; A warning
      message is produced when
      duplicates may occur in the output. They can be removed using the
      program <i>buffer.c</i>. Two important types of input never
      produce
      duplicate output: polytopes (i.e. bounded polyhedra) and cones
      (i.e.
      polyhedra where the origin is the only vertex). </p>
    <h3>
      <hr width="100%"><a name="Acknowledgements"></a> Acknowledgements
      and
      References</h3>
    I would like to thank many people for helping with this
    implementation
    project. Komei Fukuda encouraged me from the start, collaborated in
    designing the file formats, and provided many suggestions for
    improving
    the code. Debugging would have been almost impossible without the
    use
    of his program cdd as
    a benchmark. David Bremner implemented memory allocation, cacheing
    and
    signals. Ambros Marzetta demonstrated the importance of cacheing and
    lrslong is based on his earlier implementation of this as
    prs_single.&nbsp; Jerry Quinn coded the integer divide routine. Bug
    reports were provided by many users, for
    which I thank them. In particular Gerardo Garbulsky's extensive use
    of
    earlier
    versions suggested many refinements and Andreas Enge helped debug
    the
    volume
    computation. Tallman Nkgau contributed <span style="font-style:
      italic;">fourier</span>.<br>
    <p>D. Avis, lrs: A Revised Implementation of the Reverse Search
      Vertex
      Enumeration Algorithm, <a
        href="http://cgm.cs.mcgill.ca/%7Eavis/doc/avis/Av98a.ps">
        http://cgm.cs.mcgill.ca/~avis/doc/avis/Av98a.ps</a> <br>
      &nbsp;&nbsp; In: Polytopes - Combinatorics and Computation, Ed. G.
      Kalai and G. Ziegler, Birkhauser-Verlag (2000) 177-198.<br>
    </p>
    <p>D. Avis, "Computational Experience with the Reverse Search Vertex
      Enumeration Algorithm," Optimization Methods and Software, (1998
      (to
      appear)).<a
        href="http://cgm.cs.mcgill.ca/%7Eavis/doc/avis/Av98b.ps">
        http://cgm.cs.mcgill.ca/~avis/doc/avis/Av98b.ps</a> </p>
    <p>D. Avis, D. Bremner, and R. Seidel, "How Good are Convex Hull
      Algorithms?," Computational Geometry: Theory and Applications, Vol
      7,pp.265-301(1997). <a
        href="http://cgm.cs.mcgill.ca/%7Eavis/doc/avis/ABS96a.ps">
        http://cgm.cs.mcgill.ca/~avis/doc/avis/ABS96a.ps</a> </p>
    <p>D. Avis and L. Devroye, "Estimating the Number of Vertices of a
      Polyhedron," pp. 179-190 in Snapshots of Computational and
      Discrete
      Geometry, ed. D. Avis and P. Bose, School of Computer Science,
      McGill
      University (1994). <a
        href="http://cgm.cs.mcgill.ca/%7Eavis/doc/avis/AD94a.ps">
        http://cgm.cs.mcgill.ca/~avis/doc/avis/AD94a.ps</a><br>
      &nbsp; In: Information Processing Letters, (2000) V. 73, pp.
      137-143.<br>
    </p>
    <p>D. Avis and K. Fukuda, "A Pivoting Algorithm for Convex Hulls and
      Vertex Enumeration of Arrangements and Polyhedra," Discrete and
      Computational Geometry, Vol. 8, pp. 295-313 (1992).&nbsp; <a
        href="http://cgm.cs.mcgill.ca/%7Eavis/doc/avis/AF92b.ps">
        http://cgm.cs.mcgill.ca/~avis/doc/avis/AF92b.ps</a> </p>
    D. Avis, K. Fukuda and S. Picozzi, "On Canonical Representations of
    Convex Polyhedra", Mathematical Software,&nbsp; ICMS 2002, Ed. A.
    Cohen, X-S Gao, N. Takayama, World Scientific, pp.350-360
    (2002)&nbsp;
    &nbsp;<a href="http://cgm.cs.mcgill.ca/%7Eavis/doc/avis/AFP02a.ps">http://cgm.cs.mcgill.ca/~avis/doc/avis/AFP02a.ps</a><br>
    <p>D. Avis, G. Rosenberg, R. Savani, B. von Stengel, "<span
        style="font-style: italic;">Enumeration of Nash Equilibria for
        Two-Player Games</span>", <span style="font-weight: bold;">Economic

        Theory</span> 42(2009) 9-37&nbsp; <a
        href="http://cgm.cs.mcgill.ca/%7Eavis/doc/avis/ARSS09a.pdf">pdf</a>
    </p>
    <p>D. Bremner, K. Fukuda and A. Marzetta, Primal-Dual Methods for
      Vertex and
      Facet Enumeration, 13th ACM&nbsp; Symposium on Computational
      Geometry
      SCG 1997, 49-56. &nbsp; <a
        href="http://www.cs.unb.ca/profs/bremner/pd/">http://www.cs.unb.ca/profs/bremner/pd/</a>
    </p>
    <br>
    <br>
    <br>
  </body>
</html>
